# 线程基础

## 1. 程序、线程、进程？ :id=application-thread-process

- 程序

?> 程序是指令、数据及其组织形式的描述，进程是程序的实体。

- 进程

?> 我们执行的每个应用程序都是一个独立的进程，`进程是操作系统中资源分配和管理的基本单元`。
进程是应用程序的实体，表示应用程序的一次执行过程，同时进程也是线程的容器，可以运行多个子任务（线程）。

- 线程

?> 应用程序在同一时刻执行的多个任务，每一个任务都是独立运行的，想这样的子任务我们通常将它成为`线程`。
`线程是CPU调度和分派的基本单位`，它和同一个进程中的线程共享进程的内存空间。

- <i class='color-rainbow'>线程 VS 进程</i>
  1. 进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含 1--n 个线程。
  2. 同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。
  3. 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止

## 2. 守护线程和用户线程？ :id=daemon-thread

- 守护线程
  - Java 中的任何线程都可以通过`Thread#setDaemon(boolean)`方法来设置线程是否为`守护线程`，需要注意在`Thread#start()`方法执行前进行这一项的设置。
  - 守护线程是 Java 中旨在为其它用户线程提供服务的线程,比如`GC垃圾回收线程`等。
  - 常见的守护线程有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break 的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程等。

!> 守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。

- 用户线程

?> 通过应用程序创建的线程就叫做用户线程。

- <i class='color-rainbow'>守护线程 VS 用户线程</i>

?> 两者最大的差异是在 JVM 虚拟机退出的时候，守护线程旨在为用户线程提供服务，当所有的用户线程都结束了，这时守护线程也就没用了，自然也就结束服务了，此时虚拟机自然退出。

## 3. 线程实现的几种方式? :id=thread-impl

- 继承 Thread 类

  ```java
  static class ThreadA extends Thread {

    @Override
    public void run() { // 此方法必须要重写
      System.out.println(Thread.currentThread().getName());
    }
  }
  ```

- 实现 Runnable 接口

  ```java
  static class ThreadB implements Runnable {

    @Override
    public void run() {
      System.out.println(Thread.currentThread().getName());
    }
  }
  ```

- 实现 Callable 接口

  ```java
  // FutureTask<String> futureTask = new FutureTask<>(() -> Thread.currentThread().getName());

  static class ThreadC implements Callable<String> {

    @Override
    public String call() throws Exception {
      return Thread.currentThread().getName();
    }
  }
  ```

## 4. 线程的几种状态? :id=thread-state

![](/assets/images/thread-basic/20220309013005.png ':class=center :title=线程的生命周期')

- NEW: 新建状态

?> 序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值。

- RUNNABLE: 可运行状态(就绪状态)

?> 当线程对象调用了 start()方法之后，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。

- RUNNING: 运行状态

?> 处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态。

- BLOCKED: 阻塞状态

?> 阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。

- <i class='hidden'></i>

  - 等待阻塞: lockObj.wait ==> Watting Queue

  ?> 运行(running)的线程执行 lockObj.wait()方法，JVM 会把该线程放入等待队列(waitting queue)中。

  - 同步阻塞: lock==>Lock Pool

  ?> 运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中。

  - 其它阻塞: sleep/join

  ?> 运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。
  当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行(runnable)状态。

- DEAD: 死亡状态

  - 自然结束

  ?> 线程中方法结束，正常退出当前线程。

  - 异常结束

  ?> 线程中抛出未捕获的`Exception`或`Error`导致线程退出。

  - 中断/停止

  ?> 通过调用`Stop`方法结束线程，`容易导致死锁，不推荐使用`。

## 5. 优雅地终止线程的几种方式？ :id=thread-terminates

?> 停止一个线程是让当前正在运行的线程在处理完任务前停止操作。

- 自然终止

?> 线程执行结束正常退出当前线程。

- 使用退出标志退出线程

?> 通过外部实例变量来标志线程是否退出。

- interrupt()方法中断异常

?> `interrupt()`方法调用会使当前线程的中断标志位置为`true`并通知线程进行中断操作。
对于阻塞中的线程，只有线程中调用了会抛出`InterruptedException`异常的方法（`sleep()`、`wait()`、`join()`）才会进行异常中断，通过程序中不会此异常来控制线程的结束。
对于非阻塞中的线程，可以通过`isInterrupted()`判断线程的中断标志来退出循环，和通过退出标志的方式一样。

- stop()与 destory()方法

?> 这两个方法的使用可以使线程中断,调用`thread.stop()`后迫使线程强制终止，该线程所持有的所有锁的突然释放，导致持有的资源（文件描述符、网络连接等）占用不能释放。

## 6. 线程调度算法？ :id=thread-scheduling

?> 线程调度就是系统为线程分配处理器(CPU)使用权的过程。
在计算机中程序的运行依赖的是操作系统的`CPU`，在同一时间 CPU （单核）只能执行一条命令，因此每个线程都需要获取 CPU 的使用权才可以进行工作。
而CPU使用权是系统给线程分配的，系统分配CPU使用权给相应线程这个过程就是线程调度。
线程调度一般有两种调度模型：`协同式线程调度`和`抢占式线程调度`，而 JVM 虚拟机采用的则是`抢占式线程调度`。

- 协同式线程调度(Cooperative Threads-Scheduling)

?> 协同式线程调度,也称为分时调度。让所有的线程轮流获得 cpu 的使用权,并且平均分配每个线程占用的 CPU 的时间片。
线程的执行时间由线程本身来控制,线程把自己的工作执行完成之后,要主动通知系统切换到另外一个线程上。

- <i class='hidden'></i>
  - 优点: 实现简单。且由于线程要把自己的事情干完后才进行线程切换，切换操作对线程自己是可知。不存在线程同步问题。
  - 缺点: 线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，则程序会一直阻塞在那里。

- 抢占式线程调度(Preemptive Threads-Scheduling)

?> 每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定(Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有办法的)。
先让可运行池中优先级高的线程占用 CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU。
处于运行状态的线程会一直运行，直至它不得不放弃 CPU。

- <i class='hidden'></i>
  - 优点: 线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞问题，Java使用线程调度方式就是抢占式调度。
  - 缺点: 因为线程切换由系统控制，线程上下文切换会比较频繁，消耗比较多的CPU资源。

## 7. 线程上下文切换 :id=thread-context-swap

- 概述

  - 多线程这个机制是依赖于 CPU 通过给每个线程分配时间片来实现的，时间片是 CPU 分配给各个线程的时间；
  - CPU 通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms），CPU 通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务；
  - 任务切换时会保存上一个任务的执行状态，以便下一次切换回这个任务时，可以再加载这个任务的状态，所以任务从保存到再加载的过程就是一次上下文切换。

- 减少上下文切换
  - 无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁
  - CAS 算法：Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。
  - 使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。
  - 使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

## 8. 多线程与线程安全问题 :id=multi-thread-and-safe

- 多线程

?> 多线程（multit-thread），是指从软件或者硬件上实现多个线程并发执行的技术，采用并发执行机制来实现。
主要是利用`CPU`处理器的分时机制将程序`执行时间`分为若干个时间片段，每个时间片段轮流执行各个任务，由于时间片段很短，相对于一个应用程序来说，就好像是处理器在为自己单独服务一样，从而达到多个应用程序在同时进行的效果。

- 使用多线程的优势

?> <i class='emoji-sparkles title'>资源利用率提升，程序处理效率提高</i>
单核 CPU，利用处理器的分时机制，通过将时间片段分配到不同的线程，由于时间片段很短，线程切换比较快，因此看起来像过个线程同时执行的结果。
多核 CPU，通过多线程机制，将不同的 CPU 的时间片段分配到多个线程，达到充分利用多核 CPU 的利用，同时也提升了程序运行效率。

?> <i class='emoji-sparkles title'>防止阻塞</i>
对于单核 CPU 上使用多线程，相对来说并没有对程序进行多大提升，反而由于线程上下文切换导致了额外的资源消耗。
但是单核 CPU 还是要应用多线程技术的，因为在线程执行过程中，如果使用单个线程在处理过程中卡死，则会导致整个应用程序都会阻塞，多线程则很好的降低了这一影响。

- 非线程安全
  - 多个线程对同一个实例对象中同一实例变量进行操作时出现值被更改,值不同步的情况进而影响程序的执行过程
  - 非线程安全容易出现脏读(读取到的数据是被更改过的)
  - 对于方法中的局部变量是不会出现非线程安全的,只对实例变量会出现非线程安全

## 线程阻塞
- 线程阻塞的几种情况
  - 线程调用sleep方法,主动放弃占用的处理器资源
  - 线程调用阻塞式IO方法,方法返回前,该线程被阻塞
  - 线程试图获取一个同步监视器,该监视器正被其他线程持有
  - 线程等待某个唤醒通知
  - 线程调用了suspend将该线程挂起,容易导致死锁,尽量避免使用
  - run方法运行结束进入

## 9. synchronize 关键字

?> `synchronized`能修饰方法或代码块，表示修饰的方法或代码块是同步的，持有指定的对象锁，并且锁是可重入的（当线程获取一个对象锁后，再次请求此对象锁是可以再次获得的）。

- 持有锁对象
  - 对于非静态成员函数使用`synchronized`修饰，锁对象为当前实例对象。
  - 对于静态成员函数使用`synchronized`修饰，锁对象是当前实例对象属类的类对象。

- 实现原理
  ?> `synchronized`的实现主要是利用 Java 中的对象头的`Mark Word`数据块，在 64 位机器上 `Mark Word`数据块占用 8 个字节，其中维护了锁标志位和线程 ID。
  请求轻量锁 ==> 请求重量锁

## 10. volatile 关键字

?> `volatile`关键字修饰的实例变量可保证对象的值总是从公共内存中获取，从而保证了数据在线程间的可见性，但是并不能保证原子性。

- volatile 关键字的作用
  - 64 位写入的原子性（Half Write）
  - 内存可见性：使变量在多个线程间可见,强制从从公共堆栈中取得变量的值,而不是从线程私有数据栈中取得变量的值
  - 禁止指令重排序
  - 解决同步死循环
  - 解决异步死循环
  - 不支持原子性(原子性 :同生共死,要么操作都成功,要么都失败)
 
!> volatile关键字只保证了数据读取时都是从主内存中进行获取，StoreLoad内存屏障只能保证 volatile 变量的读取发生在写入之后。但是并不能保证原子性。
 示例：线程A，B同时对 volatile变量进行读取，然后分别修改了数值写回到主内存中，这时会存在并发，导致某一数据丢失更新，可以通过加锁或CAS的方式进行数值修改。

- 什么是内存可见性？

  ?> `内存可见性`问题涉及了 Java 内存模型 和 CPU 缓存架构问题,主要是在 Java 内存模型中, 将内存分为了线程共享的`主内存`和线程私有的`工作内存`。
  `内存可见性`则是保证了数据始终从`主内存`中获取，保证了多个线程并发访问数据的一致性。

## 11. 线程中的锁 :id=thread-lock

?> 在多个线程对同一资源进行访问时，为了保证数据安全，这时候就需要对资源进行访问控制，保证资源的安全访问，而`锁`的作用就是要实现线程对资源的访问控制，保证同一时间只能有一个线程去访问某个资源。

- 锁的本质：锁的本质其实就是一个对象，这个对象需要完成以下几个任务
  - 锁象内部需要有一个标志位(state 变量),记录着当前锁对象是否被某个线程占用;
  - 如果线程占用当前对象锁，记录线程编号 ID，知道具体是哪一个线程占用当前锁;
  - 线程列表,需要记录其它所有阻塞的、等待拿这个锁的线程列表，在当前线程释放锁之后，从列表中取出一个线程进行唤醒。

### 死锁与活锁

- 什么是死锁？

 ?> 指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

- 死锁产生的条件
  - 互斥条件：线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。
  - 请求和保持条件：线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。
  - 不剥夺条件：线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。
  - 环路等待条件：在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,...pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）

- 什么是活锁？
 ?> 线程本身未阻塞，但由于某些条件不满足导致不停的重试、失败、重试。
比如线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。

### 线程饥饿

?> 一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。
比如线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......，T2可能永远等待。

- 线程饥饿产生的原因？
  - 高优先级线程吞噬所有的低优先级线程的 CPU 时间。
  - 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。
  - 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。

### 11.1. 公平锁与非公平锁

- 公平锁

?> 表示线程获取锁的顺序是按照线程加锁的顺序来分配的 即: 先来先得 `FIFO` 先入先出顺序。

- 非公平锁

?> 一种获取锁的抢占机制,是非顺序获得锁的,先来的不一定先获得锁,可能会造成某些线程获取不到锁（线程饥饿）。

### 11.2. 乐观锁与悲观锁

- 乐观锁
  ?> 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现。
  乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。
  在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。

- 悲观锁

?> 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。
传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java 中 `synchronized` 和 `ReentrantLock` 等独占锁就是悲观锁思想的实现。

### 独占锁和共享锁

## 线程池 :id=thread-pool

?> 创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。

### 12. 四种线程池的区别?

通过`Executors`工具类可以创建不同类型的线程池。

- Executors.newFixedThreadPool

?> `创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。`
每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。

- Executors.newSingleThreadExecutor

?> `创建一个只有单一线程的线程池。`
这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。
线程池可以在这个唯一线程死后（或发生异常时）重新启动一个新的线程来替代它。
此线程池保证所有任务的执行顺序按照任务的提交顺序执行。

- Executors.newCacheThreadPool

?> `创建一个可缓存的线程池，可根据需要创建新线程当存在可用的缓存线程将重用它们。`
对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。
当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。
如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程。因此，长时间保持空闲的线程池不会使用任何资源。

- Executors.newShecduledThreadPool

?> 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。

### 13. 简述 ThreadPoolExecutor 的执行过程？ :id=thread-pool-executor

## 线程通信

### 线程间数据共享

- Runnable对象

 ?> 通过将`Runnable`接口对象在多个线程中进行共享从而使得资源能够共享

- 实例对象

 ?> 实例对象是在堆上进行分配的,是多个线程共享的,从而可以借助实力对象实现资源的共享
 
### 等待/通知机制 wait/notify
- wait() :使当前执行代码的线程进入等待,是Object的方法,将当前线程置入"预执行队列中",并在wait()方法所在代码行停止,直到接收到唤醒或中断为止
	- 执行wait()方法后当前线程会释放锁
- notify()方法需要在同步方法或同步代码块中调用,即:调用前需要获取当前对象锁,通知那些等待对象锁的线程参与竞争获取锁,多个线程等待,由线程规划器随机挑选出一个wait的线程进行唤醒
	- 执行notify()方法后,**当前线程不会马上释放锁**,需要等notify线程方法中的程序执行完 ,即: 退出synchronized代码块后
	- 随机唤醒等待队列中等待同一共享资源的一个线程
- wait使线程停止运行,notify使线程继续运行
- notifyAll :唤醒所有等待队列中等待同一资源的全部线程从等待中退出,进入可运行状态,优先级高的先执行,也可能随机执行

## 多线程最佳实践 

## 14. 无锁编程扩展

?> 锁是性能杀手，所以很多的前辈大师们研究如何可以不用锁，也能实现线程安全。

- 一写一读的无锁队列：内存屏障

 ?> 一写一读的无锁队列即Linux内核的kfifo队列，一写一读两个线程，不需要锁，只需要内存屏障。

- 一写多读的无锁队列：volatile关键字
- 多写多读的无锁队列：CAS
- 无锁栈
- 无锁链表
