# 网络编程专题

## 1. OSI 七层网络模型 :id=net-osi-model-7

互联网的本质就是一系列的网络协议，这个协议就叫 OSI 协议（一系列协议），按照功能不同，分工不同，人为的分层七层

![](/assets/images/tech-network/20220317182737.png ':class=center :size=50%')

- **物理层**

?> **网卡，网线，集线器，中继器，调制解调器**：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。
它的主要作用是传输比特流（就是由 0/1 转化为电流强弱来进行传输,到达目的地后在转化为 0/1，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。

- **数据链路**

?> **网卡，网线，集线器，中继器，调制解调器**：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。
在这一层工作的设备是交换机，数据通过交换机来传输。

- **网络层**

?> **路由器**：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。
在这一层工作的设备是路由器，常把这一层的数据叫做数据包。

- 传输层

?> 定义了一些传输数据的协议和端口号（WWW 端口 80 等）。
如 TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。
主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。

- **会话层**

?> 通过传输层（端口号传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）

- **表示层**

?> 主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））

- **应用层**

?> 主要是一些终端的应用，比如说 FTP（各种文件下载），WEB（IE 浏览），QQ 之类的（你就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。

## 2. TCP/IP 四层模型 :id=net-osi-model-4

![](/assets/images/tech-network/20220317220852.png ':class=center :size=50%')

- **网络访问层(Network Access Layer)**

?> 网络访问层(Network Access Layer)在 TCP/IP 参考模型中并没有详细描述，只是指出主机必须使用某种协议与网络相连。

- **网络层(Internet Layer)**

?> 网络层(Internet Layer)是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。
这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那么就必须自行处理对分组的排序。
互联网层使用因特网协议(IP，Internet Protocol)。

- **传输层(Tramsport Layer-TCP/UDP)**

?> 传输层(Tramsport Layer)使源端和目的端机器上的对等实体可以进行会话。
在这一层定义了两个端到端的协议：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协议(UDP，User Datagram Protocol)。
TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。
UDP 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。

- **应用层(Application Layer)**

?> 应用层(Application Layer)包含所有的高层协议，包括：虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。

## 3. 交换机和路由器的区别 :id=diff-switches-and-routers

?> 交换机是一种基于 MAC 地址识别，能完成封装转发数据包功能的网络设备。
路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。

- 工作层次不同

?> 交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。

- 数据转发所依据的对象不同

?> 交换机是利用物理地址或者说 MAC 地址来确定转发数据的目的地址。而路由器则是利用 IP 地址来确定数据转发的地址。IP 地址是在软件中实现的，描述的是设备所在的网络。MAC 地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而 IP 地址则通常由网络管理员或系统自动分配。

- 传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域

?> 由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有 VLAN 功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。

- 路由器提供了防火墙的服务

?> 路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。

## 4. TCP 原理 :id=tcp-transfer

### 4.1. 传输数据包 :id=tcp-transfer-data

![](/assets/images/tech-network/20220317224214.png ':class=center :size=50%')

### 4.2. TCP 协议段格式 :id=tcp-protocol-segment

![](/assets/images/tech-network/20220317225204.png ':class=center :size=50%')

- 16 位源端口号：16 位的源端口中包含初始化通信的端口。源端口和源 IP 地址的作用是标识报文的返回地址。
- 16 位目的端口号：16 位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。
- 32 位序号：32 位的序列号由接收端计算机使用，重新分段的报文成最初形式。当 SYN 出现，序列码实际上是初始序列码 （Initial Sequence Number，ISN），而第一个数据字节是 ISN+1。这个序列号（序列码）可用来补偿传输中的不一致。
- 32 位确认序号：32 位的序列号由接收端计算机使用，重组分段的报文成最初形式。如果设置了 ACK 控制位，这个值表示一个准备接收的包的序列码。
- 4 位首部长度：4 位包括 TCP 头大小，指示何处数据开始。
- 保留（6 位）：6 位值域，这些位必须是 0。为了将来定义新的用途而保留。
- 标志（6 位）：表示为：
  - URG：紧急标志。紧急标志为"1"表明该位有效。
  - ACK：确认标志。表明确认编号栏有效。大多数情况下该标志位是置位的。TCP 报头内的确认编号栏内包含的确认编号(w+1)为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。PSH：推标志。该标志置位时，接收端不将该数据进行队列处理，而是尽可能快地将数据转由应用处理。在处理 Telnet 或 rlogin 等交互模式的连接时，该标志总是置位的。
  - RST：复位标志。用于复位相应的 TCP 连接。
  - SYN：同步标志。表明同步序列编号栏有效。该标志仅在三次握手建立 TCP 连接时有效。它提示 TCP 连接的服务端检查序列编 号，该序列编号为 TCP 连接初始端（一般是客户端）的初始序列编号。在这里，可以把 TCP 序列编号看作是一个范围从 0 到 4，294，967，295 的 32 位计数器。通过 TCP 连接交换的数据中每一个字节都经过序列编号。在 TCP 报头中的序列编 号栏包括了 TCP 分段中第一个字节的序列编号。
  - FIN：结束标志。
- 16 位窗口大小：用来表示想收到的每个 TCP 数据段的大小。TCP 的流量控制由连接的每一端通过声明的窗口大小来提供。窗 口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个 16 字节字段，因而窗 口大小最大为 65535 字节。
- 16 位校验和：16 位 TCP 头。源机器基于数据内容计算一个数值，收信息机要与源机器数值 结果完全一样，从而证明数据的有 效性。检验和覆盖了整个的 TCP 报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。（检验范围包括首部和数据两部分。和 UDP 用户数据报一样，在计算校验和 时，要在 TCP 报文段加上 12 字节的伪首部。）
- 16 位紧急指针：指向后面是优先数据的字节，在 URG 标志设置了时才有效。如果 URG 标志没有被设置，紧急域作为填充。 加快处理标示为紧急的数据段。
- 选项：长度不定，但长度必须为 1 个字节。如果没有选项就表示这个 1 字节的域等于 0。
- 数据：该 TCP 协议包负载的数据。

### 4.3. 三次握手过程 :id=tcp-established-three-time

?> TCP 三次握手，其实就是建立一个 TCP 连接，客户端与服务器交互需要 3 个数据包。握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。

![](/assets/images/tech-network/20220317225248.png ':class=center :size=50%')

- 第一次握手：客户端发送 SYN 报文，并进入 SYN_SENT 状态，等待服务器的确认；
- 第二次握手：服务器收到 SYN 报文，需要给客户端发送 ACK 确认报文，同时服务器也要向客户端发送一个 SYN 报文，所以也就是向客户端发送 SYN + ACK 报文，此时服务器进入 SYN_RCVD 状态；
- 第三次握手：客户端收到 SYN + ACK 报文，向服务器发送确认包，客户端进入 ESTABLISHED 状态。待服务器收到客户端发送的 ACK 包也会进入 ESTABLISHED 状态，完成三次握手。

### 4.4. 二次握手不可以吗 :id=tcp-established-two-time

?> 首先，TCP 建立连接需要双方彼此确认对方的接收和发送能力是否正常，同时保证 TCP 传输的可靠性和安全性。

- 确认双方收发能力

  - 第一次握手，客户端发送 SYN 报文，服务端收到 SYN 信号，可以确认客户端的发送能力是正常的；
  - 第二次握手，服务端发送 ACK+SYN 报文，确认收到报文数据并发送 SYNC 信号请求建立连接，客户端收到服务端发送的 ACK+SYN，可以确认服务端的接收能力和发送能力都是正常的；
  - 上述两次握手后，还剩下服务端不能确认客户端的接收新能力，第三次握手客户端发送 ACK 信号给服务端并进入 ESTABLISHED 状态，服务端收到 ACK 信号可以确认客户端的接收能力是正常的，这时候服务端进入 ESTABLISHED 状态。

- 确认序列号的可靠同步

?> 如果只经历两次握手，则服务端不能确认客户端的接收能力，当发生第二次握手丢包的现象，则客户端无法获取服务端的初始序列号，那么 TCP 的可靠性就得不到保证了。

- 组织重复历史连接的初始化

?> 客户端由于某种原因导致发送了两个不同序列号的 SYN 报文，由于网络原因，服务端可能先收到旧的 SYN 信号并与之建立连接，而客户端收到服务端第二次握手发送的 SYN+ACK 信号，得知是旧的报文却通知不到服务端，导致客户端未能建立连接，出现网络异常的问题。
而第三次握手，如果客户端得知是旧的报文，则发送 RST 信号报文到服务端，服务端收到 RST 信号报文则废弃当前旧的报文连接请求，直到正常的 SYN 报文信号到达才建立连接。

- 安全问题
  ?> TCP 新建连接时，内核会为连接分配一系列的内存资源，如果采用两次握手，就建立连接，那会放大 DDOS 攻击的。

### 4.5. 初始序列号(ISN) :id=tcp-isn

?> ISN(Initial Sequence Number) 初始序列号是 TCP 建立连接过程中动态生成的，用于标记发送发字节数据编号的起点，ISN+1 则是第一个数据字节（服务端二次握手返回 ACK 序列号）。

### 4.6. 全连接/半连接 :id=tcp-connections

?> 服务端接收到客户端的 SYN 信号报文后则会进入 SYN-RCVD 状态，处于这一状态的连接服务端会放置在一个队列中，此时这种状态的连接就成为半连接，而此队列就是半连接队列。
当完成三次握手后，服务端进入 ESTABLISHED 状态，连接建立成功，服务端会将此连接放置到全连接队列中，此连接也就是全连接。

> [!NOTE]
> 如果全连接队列满了可能会出现丢包的现象。

### 4.7. 握手中能否携带数据 :id=tcp-established-with-data

?> 第一次和第二次握手中不能携带数据，而第三次握手是可以携带数据的。

?> 从安全上来考虑，如果第一次和第二次握手可以携带数据，那么服务端就需要耗费新能用于存储和处理这些数据，那么攻击者很容易利用这点来对服务端发起攻击，而第三次握手，客户端已经确认了服务端的接收和发送能力了，所以携带数据也是很正常的。

### 4.8. 四次挥手 :id=tcp-close-with-four-time

?> 当应用程序正常完成数据传输后需要断开连接，而 TCP 连接本身是全双工的，因此客户端客发送端都需要单独进行关闭，主要是由于 TCP 的半关闭造成的。
建立一个连接需要三次握手，而终止一个连接需要经过四次挥手。

![](/assets/images/tech-network/20220317234136.png ':class=center :size=50%')

- 第一次挥手：客户端发起 FIN 包（FIN = 1）,客户端进入 FIN_WAIT_1 状态。TCP 规定，即使 FIN 包不携带数据，也要消耗一个序号。
- 第二次挥手：服务器端收到 FIN 包，发出确认包 ACK（ack = u + 1），并带上自己的序号 seq=v，服务器端进入了 CLOSE_WAIT 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 ACK 后，进入了 FIN_WAIT_2 状态。
- 第三次挥手：服务器端数据发送完毕后，向客户端发送 FIN 包（seq=w ack=u+1），半连接状态下服务器可能又发送了一些数据，假设发送 seq 为 w。服务器此时进入了 LAST_ACK 状态。
- 第四次挥手：客户端收到服务器的 FIN 包后，发出确认包（ACK=1，ack=w+1），此时客户端就进入了 TIME_WAIT 状态。注意此时 TCP 连接还没有释放，必须经过 2\*MSL 后，才进入 CLOSED 状态。而服务器端收到客户端的确认包 ACK 后就进入了 CLOSED 状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。

- **为什么断开需要经历四次挥手？**

  - 再看三次握手

    ?> 三次握手在第二次的时候发送的数据包其实是个合并信号，SYN+ACK，因此减少了一次握手

  - 全双工模式和半关闭状态

    ?> TCP 是基于全双工模式通信的，客户端发送 FIN 信号报文请求断开连接，服务端可能还有数据需要发送，因此先发送一个确认断开的信号给客户端再继续发送数据包，当没有数据需要发送即可向客户度发送 FIN 信号请求断开。

- **为什么 TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态**

?> MSL 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 FIN 的确认包 ACK 后，这个 ACK 包是有可能不可达的，服务器端如果收不到 ACK 的话需要重新发送 FIN 包。
所以客户端发送 ACK 后需要留出 2MSL 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。
也就是说客户端如果等待 2MSL 时间也没有收到服务器端的重传包 FIN，说明可以确认服务器已经收到客户端发送的 ACK。

!> 还有一种情况为了避免新旧连接混淆。
在客户端发送完最后一个 ACK 报文段后，在经过 2MSL 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。
有些路由器会缓存 IP 数据包，如果连接重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。

### 4.9. TCP 如何保证可靠性的 :id=tcp-reliability

?> `乱序`、`丢包`、`流控`、`拥塞控制`。

## 5. HTTP原理

?> HTTP 是一个无状态的协议。无状态是指客户机（Web 浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP 遵循请求(Request)/应答(Response)模型。

### Http的传输过程

- 地址解析：http://www.baidu.com/xxxx
  - 协议名：http
  - 主机号：www.baidu.com
  - 端口：80
  - 请求路径：/xxxx

- 请求数据包封装

?> 把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包。

- TCP数据包封装和建立连接
  - 三次握手建立TCP连接
  - 封装TCP数据包

- 客户机发送请求命令

?> 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。

- 服务端响应

?> 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。

- 服务端关闭TCP连接

?> 服务器关闭 TCP 连接：一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive，TCP 连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

## HTTPS原理

?> HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。其所用的端口号是 443。

### HTTPS工作流程

![](/assets/images/tech-network/20220318131415.png ':class=center :size=50%')

- 建立连接获取证书

?> SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL 的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。

- 证书验证

?> Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。

- 数据加密和传输

?> 如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。

## 6. 网络安全 :id=net-safe

### 6.1. DDOS 攻击与防范 :id=defend-ddos

?> 目前最流行也是最好用的攻击方法就是使用 `SYN-Flood` 进行攻击，SYN-Flood 也就是 SYN 洪水攻击。
SYN-Flood 不会完成 TCP 三次握手的第三步，也就是不发送确认连接的信息给服务器。这样，服务器无法完成第三次握手，但是服务器会不停重试完成连接建立导致资源消耗。

- 防范
  - 确保服务器的系统文件是最新的版本，并及时更新系统补丁;
  - 关闭不必要的服务;
  - 限制同时打开的 SYN 半连接数目;
  - 缩短 SYN 半连接的 time out 时间;
  - 正确设置防火墙;
  - 禁止对主机的非开放服务的访;
  - 限制特定 IP 地址的访。
