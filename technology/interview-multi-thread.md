# 1. 多线程专题

## 1.1. 概念基础
### 1.1.1. 程序、进程、线程什么区别?

- 什么是程序
程序是指令、数据及其组织形式的描述，进程是程序的实体。

- 什么是进程？
我们执行的每个应用程序都是一个独立的进程，`进程是操作系统中资源分配和管理的基本单元`。
进程是应用程序的实体，表示应用程序的一次执行过程，同时进程也是线程的容器，可以运行多个子任务（线程）。

- 什么是线程？
应用程序在同一时刻执行的多个任务，每一个任务都是独立运行的，想这样的子任务我们通常将它成为`线程`。
`线程是CPU调度和分派的基本单位`，它和同一个进程中的线程共享进程的内存空间。

- <b style='color:red'>线程 VS 进程</b>
    1. 进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含 1--n 个线程。
    2. 同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。
    3. 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止

### 1.1.2. 说一下 Java 中的守护线程和用户线程的区别?

- 守护线程
    - Java 中的任何线程都可以通过`Thread#setDaemon(boolean)`方法来设置线程是否为`守护线程`，需要注意在`Thread#start()`方法执行前进行这一项的设置。
    - 守护线程是Java中旨在为其它用户线程提供服务的线程,比如`GC垃圾回收线程`等。
    - 常见的守护线程有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程等。

> [!NOTE]
> 守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。

- 用户线程
    - 通过应用程序创建的线程就叫做用户线程。

- <b style='color:red'>守护线程 VS 用户线程</b>
两者最大的差异是在JVM虚拟机退出的时候，守护线程旨在为用户线程提供服务，当所有的用户线程都结束了，这时守护线程也就没用了，自然也就结束服务了，此时虚拟机自然退出。

### 1.1.3. 说一下 Java 中是如何进行线程调度的？
在计算机中程序的运行依赖的是操作系统的`CPU`，在同一时间 CPU （单核）只能执行一条命令，因此每个线程都需要获取CPU的使用权才能执行命令。
在程序运行时，多个线程在等待CPU，轮流获取CPU的使用权，而`线程调度`则是使用特定的机制为等待的线程分配`CPU`的使用权。

- 线程调度算法
线程调度一般有两种调度模型：`分时调度模型`和`抢占式调度模型`，而JVM虚拟机采用的则是`抢占式调度模型`。
    - 分时调度模型：让所有的线程轮流获得 cpu 的使用权,并且平均分配每个线程占用的 CPU 的时间片。
    - 抢占式调度模型
        - 先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU
        - 处于运行状态的线程会一直运行，直至它不得不放弃 CPU

### 1.1.4. 什么是多线程中的上下文切换？
我们知道程序在运行时，线程通过获取CPU的使用权来执行命令，而CPU是通过时间分片的方式将使用权轮流分配给线程使用，在涉及到线程切换时发生的数据切换就是上下文切换。
在进行上下文切换时，会将当前正在运行的线程执行的具体位置等信息暂时存储起来。

### 1.1.5. 什么是死锁？什么是活锁？什么是线程饥饿？
- 什么是死锁？
    - 指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
    - 此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

- 死锁产生的条件
    - 互斥条件：线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。
    - 请求和保持条件：线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。
    - 不剥夺条件：线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。
    - 环路等待条件：在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,...pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）

- 什么是活锁？
    - 线程本身未阻塞，但由于某些条件不满足导致不停的重试、失败、重试。
    - 比如线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。

- 什么是线程饥饿？
    - 个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。
    - 比如线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......，T2可能永远等待。

- 线程饥饿产生的原因？
    - 高优先级线程吞噬所有的低优先级线程的 CPU 时间。
    - 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。
    - 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。

### Java 中的线程组是什么？为什么不推荐使用？

- 什么是线程组
    - Java 中线程可以归属于某个线程组,线程组中有线程也可以有线程组,线程组可以批量管理线程/线程组对象,有效地对线程/线程组对象进行组织。
- 为什么不推荐使用?
    - 有很多的安全隐患（具体待研究）

### 说一下 Java 中的多线程指什么？有哪些好处？
- 什么是多线程？
    - 多线程（multit-hread），是指从软件或者硬件上实现多个线程并发执行的技术，采用并发执行机制来实现。
    - 主要是利用`CPU`处理器的分时机制将程序`执行时间`分为若干个时间片段，每个时间片段轮流执行各个任务，由于时间片段很短，相对于一个应用程序来说，就好像是处理器在为自己单独服务一样，从而达到多个应用程序在同时进行的效果。

- 多线程的使用有哪些好处？
    1. 资源利用率提升，程序处理效率提高
        1. 单核CPU，利用处理器的分时机制，通过将时间片段分配到不同的线程，由于时间片段很短，线程切换比较快，因此看起来像过个线程同时执行的结果。
        2. 多核CPU，通过多线程机制，将不同的CPU的时间片段分配到多个线程，达到充分利用多核CPU的利用，同时也提升了程序运行效率。
    2. 防止阻塞
        1. 对于单核CPU上使用多线程，相对来说并没有对程序进行多大提升，反而由于线程上下文切换导致了额外的资源消耗，但是单核CPU还是要应用多线程技术的，因为在线程执行过程中，如果使用单个线程在处理过程中卡死，则会导致整个应用程序都会阻塞，多线程则很好的降低了这一影响。


## 应用实践
### 1.2.2. 线程创建的几种方式
在Java 中创建一个线程可以继承`Thread`类或实现`Runnable`接口，此外还可以通过实现`Callable`接口和`FutureTask`创建一个有返回值的线程。

- 1. 继承Thread类
    ``` java
    static class ThreadA extends Thread {
        @Override
        public void run(){  // 此方法必须要重写
            System.out.println(Thread.currentThread().getName());
        }
    }
    ```

- 2. 实现Runnable接口
    ``` java
    static class ThreadB implements Runnable {
        @Override
        public void run(){
            System.out.println(Thread.currentThread().getName());
        }
    }
    ```

- 3. 实现Callable接口
    ``` java
    // FutureTask<String> futureTask = new FutureTask<>(() -> Thread.currentThread().getName());

    static class ThreadC implements Callable<String> {
        @Override
        public String call() throws Exception{
            return Thread.currentThread().getName();
        }
    }
    ```

- <b style='color:red'>方式一 VS 方式二</b>
    - 区别：继承`Thread`，不适合资源共享，实现了`Runable`接口的话，则很容易的实现资源共享。
    - 实现Runnable接口的优势
        1. 适合多个相同的程序代码的线程去处理同一个资源。
        2. 可以避免 java 中的单继承的限制。
        3. 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。

### 1.2.3. start() VS run()
`start()`方法是线程启动由`NEW`(新创建)->`Runnable`(就绪)的入口方法，通过此方法调用才能开启一个新的线程，具体线程的调度执行由操作系统决定。
`run()`方法是线程体，主要是线程的具体行为，单独调用此方法，仅仅是在当前线程中执行了线程对象的行为方法并没有开启一个新的线程。
    
### 1.2.4. Runnable接口和Callable接口
这两个接口都能完成线程的创建，其中`Runnable`接口是线程创建的标椎接口，接口中有一个无参的返回值为`void`的功能方法。由此创建的线程仅仅完成行为动作。
`Callable`接口中有个无参的具有返回值对象的`call()`方法，配合`Future`、`FutureTask`创建一个有返回值的线程，可以通过异步获取执行结果。

### 1.2.5. Java中Semaphore是什么？
Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。更多详细信息请点击这里。

### 1.2.6. `CyclicBarrier` VS `CountDownLatch`
两个看上去有点像的类，都在java.util.concurrent下的同步工具类，都可以用来表示代码运行到某个点上，都可以用来让一组线程等待其它线程。

- 区别
    - CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行。
    - CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务。
    - CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了。

### 1.2.7. Java内存模型是什么？
为了明确定义在多线程场景下，什么时候可以重排序，什么时候不能重排序，Java引入了JMM（Java Memory Model），也就是Java内存模型。
这个模型就是一套规范，对上，是JVM和开发者之间的协定；对下，是JVM和编译器、CPU之间的协定。
Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。

为了描述这个规范，JMM引入了happen-before，使用happen-before描述两个操作之间的内存可见性。

- happen-before
如果一个线程A在线程B之前执行，则需要保证线程A的执行结果对线程B是可见的也就是`内存可见性`。
    - 单线程中的每个操作，happen-before 对应该线程中任意后续操作（也就是as-if-serial语义保证）。
    - 对volatile变量的写入，happen-before对应后续对这个变量的读取。
    - 对synchronized的解锁，happen-before对应后续对这个锁的加锁。
    - 对final变量的写，happen-before于final域对象的读，happen-before于后续对final变量的读。

对于非volatile变量的写入和读取，不在这个承诺之列。通俗来讲，就是JMM对编译器和CPU 来说，volatile 变量不能重排序；非volatile 变量可以任意重排序。

- happen-before的传递性
除了上述这些基本的happen-before规则，happen-before还具有传递性，即若Ahappen-before B，B happen-before C，则A happen-before C。

- JSR-133对volatile语义的增强
在旧的JMM模型中，volatile变量的写入会和非volatile变量的读取或写入重排序。但新的模型不会，这也正体现了Java对happen-before规则的严格遵守。

### 1.2.8. Java中的volatile 变量是什么？
volatile关键字修饰的实例变量可保证对象的值总是从公共内存中获取，从而保证了数据在线程间的可见性，但是并不能保证原子性。

- 作用
  - 内存可见性：使变量在多个线程间可见,强制从从公共堆栈中取得变量的值,而不是从线程私有数据栈中取得变量的值
  - 禁止指令重排序
  - 解决同步死循环
  - 解决异步死循环
  - 不支持原子性(原子性 :同生共死,要么操作都成功,要么都失败)

### 1.2.9. 一个线程运行时发生异常会怎样？
如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。

### 1.2.10. 如何在两个线程间共享数据？
- Runnable对象实现资源共享
- 实例变量实现资源共享

### 1.2.11. Java中notify 和 notifyAll有什么区别？
notify()方法需要在同步方法或同步代码块中调用,即:调用前需要获取当前对象锁,通知那些等待对象锁的线程参与竞争获取锁,多个线程等待,由线程规划器随机挑选出一个wait的线程进行唤醒
执行notify()方法后,当前线程不会马上释放锁,需要等notify线程方法中的程序执行完 ,即: 退出synchronized代码块后
notifyAll :唤醒所有等待队列中等待同一资源的全部线程从等待中退出,进入可运行状态,优先级高的先执行,也可能随机执行

### 1.2.12. 什么是ThreadLocal变量？

### 1.2.13. 什么是FutureTask？
在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。

### 1.2.14. Java中interrupted 和 isInterruptedd方法的区别？

### 1.2.15. 为什么wait和notify方法要在同步块中调用？
等待/通知机制本身就需要同步进行阻塞，因此需要和synchronized一起使用，由于synchronized持有的是对象锁，因此锁本身是对象，因此wait（）和notify（）要同样如此普及，也只能放在Object里面了。

### 1.2.16. 什么是线程池？ 为什么要使用它？
创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。更多内容详见这篇文章。

### 1.2.17. 如何写代码来解决生产者消费者问题？
比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，这篇教程有实现它。

### 1.2.18. 怎么检测一个线程是否拥有锁？
在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。

### 1.2.19. Thread类中的yield方法有什么作用？
Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。

### 1.2.20. Java中ConcurrentHashMap的并发度是什么？
ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。

### 1.2.21. 如果你提交任务时，线程池队列已满。会时发会生什么？
事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。

### 1.2.22. Java线程池中submit() 和 execute()方法有什么区别？
两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口。

### 1.2.23. 什么是阻塞式方法？
阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。更多详细信息请点击这里。

### 1.2.24. Java中的ReadWriteLock是什么？
一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。

### 1.2.25. 多线程中的忙循环是什么?
忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。你可以查看这篇文章获得更多信息。

### 1.2.26. volatile 变量和 atomic 变量有什么不同？
这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。

### 1.2.27. 如果同步块内的线程抛出异常会发生什么？
这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。

### 1.2.28. 单例模式的双检锁是什么？
这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。你可以查看how double checked locking on Singleton works这篇文章获得更多信息。

### 1.2.29. 如何在Java中创建线程安全的Singleton？
这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。你可以查看这篇文章获得更多信息。

### 1.2.30. 写出3条你遵循的多线程最佳实践
给你的线程起个有意义的名字。
    这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。
避免锁定和缩小同步的范围
    锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。
多用同步类少用wait 和 notify
    首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。
多用并发集合少用同步集合
    这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。我的文章Java并发集合有更详细的说明。

### 1.2.31. 如何强制启动一个线程？
这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。

### 1.2.32. Java中的fork join框架是什么？
fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。

### 1.2.33. JVM中的锁升级