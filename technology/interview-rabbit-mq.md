# 1. RabbitMQ 专题

## 1.1. 概念基础

### 1.1.1. 什么是 RabbitMQ？

- RabbitMQ 是一种实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）
- 最大的特点就是消费并不需要确保提供方存在,实现了服务之间的高度解耦

### 1.1.2. 为什么要使用 RabbitMQ?

- 在分布式系统下具备异步,削峰,负载均衡等一系列高级功能;
- 拥有持久化的机制，进程消息，队列中的信息也可以保存下来
- 实现消费者和生产者之间的解耦。
- 对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量的限流，利于数据库的操作。
- 可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。

### 1.1.3. 说几个 RabbitMQ 的使用场景?

- 服务间异步通信(业务解耦)
- 顺序消费
- 定时任务
- 流量削峰

### 1.1.4. 说一下使用 RabbitMQ 带来的好处?

- 业务解耦:服务间高度解耦
- 异步通信性能高
- 流量削峰

### 1.1.5. 在使用 RabbitMQ 时有没有什么缺点呢?

- **系统可用性降低**<br>
  &emsp;&emsp;系统引入的外部依赖越多，越容易挂掉，在现有的业务系统中引入了`MQ`服务，原有的正常业务系统可能会由于`MQ`服务的宕机导致整套系统崩溃，就有点得不偿失了。

- **系统复杂性提高**<br>
  &emsp;&emsp;引入`MQ`服务后，开发人员需要确保消息的幂等性（消息重复推送、重复消费），消息是否丢失以及如何保证消息传递的顺序等问题。

- **一致性问题**<br>
  &emsp;&emsp;在涉及多个业务系统的交互过程中，引入了`MQ`可能会导致发起方业务正常处理成功了，在后续消费者系统进行业务处理过程中，个别系统处理失败，导致数据不一致问题，就需要开发人员在进行架构设计和业务开发过程中人为的避免这些问题的发生。

### 1.1.6. 简单说一下 RabbitMQ 的消息推送和消息消费的过程？

- **生产者-消息推送**
  1. 发送端 MQ-client 将消息发给服务端 MQ-server
  2. 服务端 MQ-server 将消息落地（消息存储或持久化）
  3. 服务端 MQ-server 回 ACK 给发送端 MQ-client

> [!NOTE]
> 如果此处**第三步**丢失,则发送端 MQ-client 超时后会重发消息，可能导致服务端 MQ-server 收到重复消息，导致消息重复推送。

- **消费者-消息消费**
  1. 服务端 MQ-server 将消息发给接收端 MQ-client
  2. 接收端 MQ-client 回 ACK 给服务端
  3. 服务端 MQ-server 将落地消息删除

> [!NOTE]
> 如果此处**第二步**丢失,则服务端 MQ-server 超时后会重发消息，可能导致 MQ-client 收到重复的消息，导致重复消费的现象产生。

## 1.2. 实践应用

### 1.2.1. 如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？

- **发送方确认模式**

  - 将信道设置成`confirm`模式(发送方确认模式),则所有在信道上发布的消息都会被指派一个唯一的`ID`,一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。
  - 如果`RabbitMQ`发生内部错误从而导致消息丢失，会发送一条 nack（not acknowledged，未确认）消息。
  - 发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。

- **接收方确认机制**
  - 消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。
  - RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性；

### 1.2.2. 如果避免消息重复推送和消息重复消费（消息幂等）？

在 [1.1.4. 简单说一下 RabbitMQ 的消息推送和消息消费的过程？](#_114-简单说一下-rabbitmq-的消息推送和消息消费的过程？) 中介绍了消息重复推送和重复消费现象的产生。

- **生产者-重复推送问题**

  - MQ 内部针对每条生产者发送的消息生成一个`inner-msg-id`，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列,这个内部消息 ID 的特性是：
    - 全局唯一
    - MQ 生成，具备业务无关性，对消息发送方和消息接收方屏蔽

- **消费者-重复消费问题**
  - 要求业务消息体中必须要有一个`bizId`（对于同一业务全局唯一，如支付 ID、订单 ID、帖子 ID 等）作为去重和幂等的依据，避免同一条消息被重复消费,这个业务 ID 的特性是
    - 对于同一个业务场景，全局唯一
    - 由业务消息发送方生成，业务相关，对 MQ 透明
    - 由业务消息消费方负责判重，以保证幂等

> [!TIP]
> 以上也是保证消息队列中消息幂等的基本方案。

### 1.2.3. 说一下消息队列中消息是基于什么传输？

&emsp;&emsp;由于`TCP`连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。`RabbitMQ` 使用 Channel(信道)的方式来传输数据。<br>
&emsp;&emsp;信道是建立在真实的`TCP`连接内的虚拟连接，且每条`TCP`连接上的信道数量没有限制。

### 1.2.4. 说一下消息队列中的消息是如何进行分发的?

&emsp;&emsp;若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。<br>
&emsp;&emsp;通过路由机制可实现多消费的功能。

### 1.2.5. 说一下消息队列中的消息是如何进行路由的?

&emsp;&emsp;消息提供方->路由->一至多个队列<br>

- **消息路由**

  1. 消息先发送到交换器时，消息会拥有一个路由键（Routing Key），在消息创建时指定。
  2. 通过队列路由键，可以把队列绑定到交换器上。
  3. 消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）。

- **常用的交换器**
  - fanout：如果交换器收到消息，将会广播到所有绑定的队列上
  - direct：如果路由键完全匹配，消息就被投递到相应的队列
  - topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符

### 1.2.6. 说一下怎么能确保消息队列中的消息不丢失?

&emsp;&emsp;为了确保消息队列中的消息不丢失，首先要保证消息持久化，当然前提是队列必须持久化。

- **消息队列的持久化** - 将它们写入磁盘上的一个持久化日志文件，当发布一条持久性消息到持久交换器上时，RabbitMQ 会在消息提交到日志文件后才发送响应。 - 消费者从持久队列中消费了一条持久化消息，RabbitMQ 会在持久化日志中把这条消息标记为等待垃圾收集。
  > [!TIP]
  > 如果持久化消息在被消费之前 RabbitMQ 重启，那么 RabbitMQ 会自动重建交换器和队列（以及绑定），并重新发布持久化日志文件中的消息到合适的队列。

### 1.2.7. 了解过 RabbitMQ 的集群吗？简单说一下是怎么实现的?
    
&emsp;&emsp;RabbitMQ 采用的`镜像集群模式`，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，然后每次你写消息到 queue 的时候，都会自动把消息到多个实例的 queue 里进行消息同步。<br>

&emsp;&emsp;这样做的好处很明显，任何一台机器宕机了，其它机器都能正常使用，但是如果消息队列中的消息过多，在进行同步带来的性能消耗和带宽压力也是非常大的，尤其是不能进行线性扩容。
