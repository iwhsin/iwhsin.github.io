# 1. Java 基础专题

## 1.1. 基本概念

### 1.1.1. Java 语言基本特点

&emsp;&emsp;总结一下，Java 语言的特点有`简单`、`面向对象`、`体系结构中立（平台无关）`、`安全`、`可移植`、`多线程`、`动态性`等。

> [!NOTE]
> 可以参考：[Java 语言特性](docs/basic/java-language-feature/introduction/java-language-conceptual.md#_13-语言特性)

### 1.1.2. 面向对象和面向过程的区别

- **面向过程**

  - 面向过程是一种以过程为中心的编程思想。关注的是功能的实现，将问题分解为一个一个步骤，然后通过函数调用一步一步地实现这些步骤。
  - 什么是过程呢？这些解决问题的步骤就是过程，是一种自顶而下的编程模式，强调的是功能实现。
  - 优点：面向对象属于直奔目的，避免了一些非必要资源的占用，因此相对占用资源较少，速度较快，性能相对较高；
  - 缺点：相对来说面向过程不便于维护、扩展。

- **面向对象**
  - 面向对象是一种以对象为中心的编程思想，关注的是封装行为的对象。将构成问题的各个事物抽象为具体的对象，对象中封装了对应的特征和行为，在通过对象间行为的调用来解决问题。
  - 面向对象时一种高度抽象化的编程模式，强调的是封装功能的具体对象。
  - 优点：面向对象的特性（封装、继承、多态等）决定了面向对象更便于维护、复用和扩展，可以设计出低耦合的系统，使得程序更加灵活、易于维护。
  - 缺点：面向对象需要对对象进行实例化创建，开销比较大，相对来说更占用系统资源，性能相对较低。

> [!NOTE]
> 可以参考：[面向对象 VS 面向过程](docs/basic/java-language-feature/object-oriented/object-oriented-And-process-oriented)

### 1.1.3. 面向对象编程的基本特性有哪些?

- **封装**
- **继承**
- **多态**
- **抽象**

> [!NOTE]
> 可以参考：[面向对象的设计准则](docs/basic/java-language-feature/object-oriented/object-oriented-criteria)

### 1.1.4. Java 是解释性语言吗?

- **什么是解释性语言？**<br>
  &emsp;&emsp;我们都知道计算机只能理解机器语言，而高级语言编写的程序若要被计算机进行执行，必须要先将高级语言翻译为机器语言，再由计算机进行执行，而翻译的形式一般有两种：`解释` 和 `编译`。<br>
  &emsp;&emsp;在 Java 语言中，`JVM`虚拟机基本上算是解释器（JIT 编译大大提升了性能）。而`JVM`解释执行的是`字节码`，需要先用`javac`将源码编译为`字节码`。因此，可以看出 Java 并不完全算是解释性语言。<br>
  &emsp;&emsp;常见的解释性语言有`python`、`javascript`等，在程序运行时，边解释边执行，执行效率较低，而且解释性语言的运行结果可能会受到环境的影响（比如`python2`和`python3`）。

### 1.1.5. Java 平台无关性的具体体现在哪?

&emsp;&emsp;java 语言的一个基本特性是可移植，跨平台，`一次编写，处处运行`。<br>
&emsp;&emsp;java 的平台无关性主要依靠`java语言规范`、`class文件`和`JVM虚拟机`。

- **Java 语言规范**<br>
  &emsp;&emsp;Java 中基本数据类型的值域和行为都是由其自己定义的。

- **Class 文件**<br>
  &emsp;&emsp;Java 有着统一的`class`文件，在不同平台编译的`class`文件是一样。

- **JVM 虚拟机**<br>
  &emsp;&emsp;Java 虚拟机提供了各个平台的版本，根据统一的`class`文件，JVM 经过编译成对应平台的机器码进行解释执行，实现了 java 的平台无关性。

### 1.1.6. Java 语言中是值传递还是引用传递?

- **什么是值传递?**<br>
  &emsp;&emsp;`值传递（pass by value）`是指在调用函数时将实际参数`复制`一份传递到函数中，这样在函数中如果对`参数`进行修改，将不会影响到实际参数。<br>
  &emsp;&emsp;值传递传递的是一个对象的副本，对副本的修改不会对对象原本的信息造成影响。

- **什么是引用传递？**<br>
  &emsp;&emsp;`引用传递（pass by reference）`是指在调用函数时将实际参数的地址`直接`传递到函数中，那么在函数中对`参数`所进行的修改，将影响到实际参数。
  &emsp;&emsp;引用传递是传递的对象自身，在被调用的位置对传递的对象修改，也是对对象自身进行修改，会影响到对象本身。

- **为什么 Java 中是值传递?**<br>
  &emsp;&emsp;我们知道在 Java 中调用方法将引用对象传递给函数时,在函数中对引用对象本身进行修改,如重新指向另一个实例对象,而引用对象本身所在的位置中的对象并未发生变化,因此作为形参传递给函数的其实是引用对象本身的一个拷贝的副本。

> [!NOTE]
> 可以参考：[值传递 VS 引用传递](docs/basic/java-language-feature/base-feature/passes-object-by-reference-or-value)

### 1.1.7. 方法重写和方法重载的区别？

- **方法重写**<br>
  &emsp;&emsp;方法重写是指在子类继承父类，重新实现父类的某一方法，方法的名称和参数与父类中的方法相同，重写允许子类提供其父类已经提供的方法的特定实现。<br>
  &emsp;&emsp;方法重写是一个`运行时概念`，程序运行时使用哪一个重写是由运行时实际的对象类型（而不是引用变量的类型）确定的，重写也是`运行时`多态的主要体现方式。

- **方法重载**<br>
  &emsp;&emsp;方法重载是指在一个类中有两个或多个方法具有相同方法名但参数列表不同，就会发生重载。<br>
  &emsp;&emsp;方法重载是一个`编译时概念`，由引用变量类型确定在编译时使用哪种重载方法。

> [!NOTE]
> 可以参考：[方法重写 VS 方法重载](docs/basic/java-language-feature/base-feature/overriding-and-overloading)

### 1.1.8. 继承和组合的联系与区别?

- **什么是继承？**<br>
  &emsp;&emsp;继承（Inheritance）是一种联结类与类的层次模型。是指一个类(子类、子接口)继承另一个类（父类、父接口），拥有被继承类的相关属性和功能。<br>
  &emsp;&emsp;继承是`is-A`的概念。

- **什么是组合？**<br>
  &emsp;&emsp;组合(Composition)体现的是整体与部分、拥有的关系，即`has-a`的关系。

> [!NOTE]
> 可以参考：[继承 VS 组合](docs/basic/java-language-feature/base-feature/composite-reuse-principle)

### 1.1.9. Java 为什么被设计为单继承?

&emsp;&emsp;在已知的面向对象（OOP）高级语言中，除了`C++`几乎所有的语言都默认从一个基类继承，当然`Java`也不例外。<br>
&emsp;&emsp;Java 语言中有一个特殊的类`Object`，它是所有类的基类，其它类都是直接或间接继承自`Object`类。

- **单继承设计的好处**
  - `单继承`的设计保证了所有对象都直接或间接具有一个公共基类，在一定程度上保证了系统的安全。
  - `单继承`的设计保证了在实现多态时保证了方法的调用准确性。
  - `单继承`的设计在系统进行垃圾回收时，可以很容易确认对象的类型，使垃圾回收变得更容易。

### 1.1.10. Java 中的引用对象有哪几种引用类型?

- 强引用
- 软引用
- 弱引用
- 虚引用

> [!NOTE]
> 可以参考：[值传递 VS 引用传递](docs/basic/java-language-feature/base-feature/object-reference-type)

### 1.1.11. 平时工作开发中常用的类、包、接口。

- java.lang: 提供利用 Java 编程语言进行程序设计的基础类
  - 包装类 Byte、Integer、Float 等
  - Class、ClassLoader、Runtime、Object、System、Thread、String、StringBuffer、Math
  - 异常、错误等
- java.util: 常用的工具类
  - 集合库 Map Collection
  - Scanner、Splitator、StringJoiner、StringTokenize、UUID、Date、Calendar、Random
- java.io: 输入输出流
  - 字节流
    - 输入流
    - 输出流
    - 装饰流
  - 字符流
- java.net: 网络编程
- java.awt: java 的画图工具包
- java.sql: 数据库连接
  - Drive、Connection、ResultSet
- java.text: 操作文本
- java.time: 时间日期相关
  - JDK-1.8 新提供 LocalDate、LocalTime、Duration、Instant、ZonedDateTime 等
- java.beans: 主要类的定义和修饰
- java.math: 科学计算
  - BigDecimal
  - BigInteger

### 1.1.12. Java 中类、接口、方法等适用的修饰符

- 类：public、protect、private、abstract、static、final、strict
- 接口：public、protect、private、abstract、static、strict 注意不能用 final 修饰
- 构造方法：public、protect、private
- 方法：public、protect、private、abstract、static、final、strict、synchronize、native
- 字段：public、protect、private、static、final、volatile、transient
- 形参：final

### 1.1.13. 基本数据类型与包装类

> [!NOTE]
> 可以参考：[Java 中的数据类型结构](docs/basic/base-java/java-data-types)

### 1.1.14. 介绍一下 Java 中的内部类和合成类

- **内部类**<br>
  &emsp;&emsp;java 中的类、接口、枚举类等都是顶层类型，独立于其它类型。此外，类还可以嵌套在其它类型中进行定义，这就是`嵌套类型`（nested type），一般称为`内部类`。

- **内部类的作用**：内部类主要是为了**对象的封装**。

  - 如果某个类型需要特别深入地访问另一个类型的内部实现，可以嵌套定义这个类型。作为成员类型的嵌套类型，其访问方式与访问成员变量和方法的方式一样，而且能打破封装的规则。
  - 某个类型可能只在特定的情况下需要使用，而且只在非常小的代码区域使用。这个类型应该密封在一个小范围内，因为它其实是实现细节的一部分，应该封装在一个系统的其他部分无法接触到的地方。

- **内部类的实现方式**
  - 静态内部类
  - 成员内部类
  - 匿名内部类

> [!NOTE]
> 可以参考：[内部类与合成类](docs/basic/base-java/inner-and-composite-class)

### 1.1.15. Java 中的枚举类型

> [!NOTE]
> 可以参考：[枚举类型](docs/basic/base-java/java-enum-class)

### 1.1.16. Java 中的接口类型

> [!NOTE]
> 可以参考：[接口类型](docs/basic/base-java/java-interface-class)

### 1.1.17. Java 中的注解类型

> [!NOTE]
> 可以参考：[注解类型](docs/basic/base-java/java-annotation-class)

### 1.1.18. Java 中的泛型机制

> [!NOTE]
> 可以参考：[泛型类型和泛型方法](docs/basic/base-java/java-generic-class)

## 1.2. 面向对象编程

### 1.2.1. Java 中对象创建的几种方式?

- **创建方式**

  1. 通过`new`关键字：显示调用类的构造函数进行对象的创建。
  2. 反射：通过`Class`或`Constructor`类的`newInstance()`方法来进行类的创建
  3. clone：通过`clone`创建，这种方式需要类实现`Cloneable`接口，并按照需要决定是否重写`clone()`方法。
  4. 通过反序列化的手段创建。

- **区别**
  1. 方式 1 和方式 2 会显式的调用类的构造方法进行类的实例化创建。
  2. 方式 3 是在内存中通过二进制流的形式完成对象的复制不会进行构造方法的调用。
  3. 方式 4 是从文件中完成类的读取创建，也不会调用类的构造方法。

### 1.2.2. equals()方法和`==`的区别?

- `equals`：
  - `equals`是比较对象的值，默认继承自 Java 中的顶层类`Object`的`equals(Object obj)`，不重写则等同于`==`。
- `==`：
  - `==`是比较引用对象指向的对象的内存地址，这里的内存地址指的是对象引用指向的堆中的对象的内存地址。
  - 举个例子说明下：方法调用中的形参，参数传入到方法中，此时传入的是参数对象的引用地址的副本，和原引用对象指向的是同一个内存地址中的对象。

### 1.2.3. 简单说下类变量、成员变量和局部变量的区别？

- **类变量**<br>
  &emsp;&emsp;`类变量`也就是静态变量，在类加载的时候完成初始化操作，属于类共享的变量是存放在`JVM`的方法区中。

- **成员变量**<br>
  &emsp;&emsp;`成员变量`是实例化对象的变量，存放在`JVM`的堆内存中，属于线程共享的。

- **局部变量**<br>
  &emsp;&emsp;`局部变量`代码块或者方法中声明的变量类型，存放在`JVM`的栈内存中，属于线程私有的变量。

### 1.2.4. 介绍下 Java 中 final 关键字？

&emsp;&emsp;在 java 中`final`关键字可用来修饰`成员变量`、`局部变量`、`方法`、`类`，表示了不可变性。

- 使用：
  - `final`修饰的类，表示类不可被继承；
  - `final`修饰的方法，表示方法不可被重写；
  - `final`修饰的成员变量，声明后值不可修改，和`static`使用表示类的编译时常量；
  - `final`修饰的局部变量，表示值不可修改的局部变量。

### 1.2.5. final 关键字修饰的类，它的方法和属性都是默认`final`吗？

&emsp;&emsp;`final`修饰的类，它的方法和属性如果未声明`final`，则它们并不是默认`final`修饰的。

> [!NOTE]
> 可以参考：[Java 中的修饰符](docs/basic/base-java/modifier-in-java)

### 1.2.6. 为什么内部类中不能使用非`final`修饰的变量？

&emsp;&emsp;在内部类中传入的局部变量的引用，如果不声明为`final`，在内部类对变量进行了修改，则会出现意想不到的逻辑错误等问题。

> [!NOTE]
> 可以参考：[内部类与合成类](docs/basic/base-java/inner-and-composite-class)

### 1.2.7. 说一下 Java 中的反射机制及作用

- **什么是反射？**<br>
  &emsp;&emsp;Java 中的反射机制（reflection）是指在程序运行时动态获取类对象信息和动态调用类的对象功能。

- **反射有什么作用**

  - 在运行时判断任意一个对象所属的类；
  - 在运行时构造任意一个类的对象；
  - 在运行时判断任意一个类所具有的成员变量和方法；
  - 在运行时调用任意一个对象的方法；
  - 生成动态代理。

- **反射的实现**<br>
  &emsp;&emsp;java 中反射的实现依赖`java.lang.Class`类，在 java 中每个`.class`在虚拟机进行类加载的时候都会创建对应的`Class`对象，在运行时，通过`Class`对象获取对应的类的属性和行为信息。<br>
  &emsp;&emsp;在程序运行期间，Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。

### 1.2.8. 说一下 Java 中的动态代理是什么？

&emsp;&emsp;Java 中的动态代理是指在程序运行时动态创建一个实现了一组给定接口的新类。

> [!NOTE]
> 可以参考：[Java 中的动态代理](docs/basic/object-oriented-programming/reflection/dynamic-proxy-in-java)

### 1.2.9. 说一下 Java 中的序列化机制

- **Java 中的序列化是什么?**<br>
  &emsp;&emsp;序列化是将内存中各种对象状态进行持久化存储，并能在需要的时候将对象进行还原。<br>

- **Java 中序列化有什么作用**

  - 当需要将内存中的对象保存到数据库或者文件中；
  - 当需要在网络中进行对象传输；
  - 但需要通过远程方法调用（RMI）传输对象时；

- **Java 中对象序列化的使用**<br>
  &emsp;&emsp;java 中实现序列化可以通过实现`Serializable`或`Externalizable`接口。

> [!NOTE]
> 可以参考：[Java 中的序列化与反序列化](docs/basic/object-oriented-programming/file-and-io/serialization-and-deserialization-in-java)

## 1.3. 注解

- **注解类型介绍**

  - java 中的注解是在`Java 5`中引入的一种特殊的接口，其作用是注解 Java 程序的某个部分。
  - 注解本身没有没有什么直接的作用，只是为注解的地方额外提供某些信息。
  - 注解不能改变程序的语义，只能提供可选的元信息。

- **自定义注解**

  - 使用`@interface`关键字定义一个类为注解类型；
  - 使用`元注解`（元注解是特殊的注解，用来注解自定义注解类型的注解）；
    - 开发者使用`元注解`指定新的注解类型的使用范围（`@Target`）和保留原则（` @Retention`）；
    - `@Target`元注解：指明自定义的新注解能在 Java 程序中的哪些地方使用，可用的枚举值在`ElementType`中定义，包括`TYPE、FIELD、METHOD、PARAMETER、CONSTRUCTOR、LOCAL_VARIABLE、ANNOTATION_TYPE、PACKAGE、TYPE_PARAMETER和TYPE_USE`；
    - `@Retention`元注解：指明`javac`和`JVM`运行时如何处理自定义的注解类型。可使用的值有三个，在枚举`RetentionPolicy`中定义。
      - `SOURCE`：这个保留原则的注解表明该注解只在源码中有效，编译时会自动抛弃；
      - `CLASS`：这个保留原则的注解表明该注解在编译时会出现在类文件中，但运行时`JVM`无法访问，这个值很少使用，但有时会在`JVM`字节码的离线分析工具中见到；
      - `RUNTIME`：表示用户的代码在运行时（使用反射）能访问这个注解。

- **注解接口的特性（和普通接口比较）**
  - 都（隐式）继承`java.lang.annotation.Annotation`接口；
  - 不能泛型化；
  - 不能继承其它接口；
  - 只能定义没有参数的方法；
  - 不能定义会抛出异常的方法；
  - 方法的返回类型有限制；
  - 方法可以有一个默认的返回值。

## 1.4. 枚举类

- **枚举类有什么用呢？**

  - 我们平时定义一个枚举值一般会使用常量进行定义，而枚举类为我们定义枚举值提供了一种更好的实现。
  - 枚举类本身也是一种类，可以有属性和方法，也符合了我们面向对象的编程。
  - 比起常量定义枚举值，枚举类可以为我们提供更多的关于枚举值的信息。

- **枚举类的特性（注意点）**
  - 所有的枚举类都默认继承了`java.lang.Enum`类,可以通过`StateEnum.STATE_ON.getClass().getSuperclass()`查看；
  - 枚举类不支持泛型化，不能有类型参数`type parameter`；
  - 可以实现接口；
  - 不能被继承；
  - 可以有抽象方法，如果枚举中的所有值都要有自己的实现，可以在枚举类中选择定义一个抽象方法。
  - 只能有一个私有（或使用默认访问权限）的构造方法。

## 1.5. Java 中的引用类型

### 1.5.1. 强引用

&emsp;&emsp;强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。

### 1.5.2. 软引用

&emsp;&emsp;软引用（soft reference）在强度上弱于强引用，通过类 SoftReference 来表示。它的作用是告诉垃圾回收器，程序中的哪些对象是不那么重要，当内存不足的时候是可以被暂时回收的。<br>
&emsp;&emsp;当 JVM 中的内存不足的时候，垃圾回收器会释放那些只被软引用所指向的对象。如果全部释放完这些对象之后，内存还不足，才会抛出 OutOfMemory 错误。软引用非常适合于创建缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。

### 1.5.3. 弱引用

&emsp;&emsp;在强度上弱于软引用，通过类 WeakReference 来表示。它的作用是引用一个对象，但是并不阻止该对象被回收。如果使用一个强引用的话，只要该引用存在，那么被引用的对象是不能被回收的。<br>
&emsp;&emsp;弱引用则没有这个问题。在垃圾回收器运行的时候，如果一个对象的所有引用都是弱引用的话，该对象会被回收。<br>
&emsp;&emsp;弱引用的作用在于解决强引用所带来的对象之间在存活时间上的耦合关系。弱引用最常见的用处是在集合类中，尤其在哈希表中。哈希表的接口允许使用任何 Java 对象作为键来使用。当一个键值对被放入到哈希表中之后，哈希表对象本身就有了对这些键和值对象的引用。如果这种引用是强引用的话，那么只要哈希表对象本身还存活，其中所包含的键和值对象是不会被回收的。如果某个存活时间很长的哈希表中包含的键值对很多，最终就有可能消耗掉 JVM 中全部的内存。<br>
&emsp;&emsp;对于这种情况的解决办法就是使用弱引用来引用这些对象，这样哈希表中的键和值对象都能被垃圾回收。Java 中提供了 WeakHashMap 来满足这一常见需求。

### 1.5.4. 虚引用

&emsp;&emsp;在介绍幽灵引用之前，要先介绍 Java 提供的对象终止化机制（finalization）。在 Object 类里面有个 finalize 方法，其设计的初衷是在一个对象被真正回收之前，可以用来执行一些清理的工作。因为 Java 并没有提供类似 C++的析构函数一样的机制，就通过 finalize 方法来实现。但是问题在于垃圾回收器的运行时间是不固定的，所以这些清理工作的实际运行时间也是不能预知的。幽灵引用（phantom reference）可以解决这个问题。在创建幽灵引用 PhantomReference 的时候必须要指定一个引用队列。当一个对象的 finalize 方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了。
&emsp;&emsp;幽灵引用及其队列的使用情况并不多见，主要用来实现比较精细的内存使用控制，这对于移动设备来说是很有意义的。程序可以在确定一个对象要被回收之后，再申请内存创建新的对象。通过这种方式可以使得程序所消耗的内存维持在一个相对较低的数量。比如下面的代码给出了一个缓冲区的实现示例

## 1.6. 函数式编程

### 1.6.1. 函数式编程概念

&emsp;&emsp;`函数式编程`是一种`编程范式（编写程序命令的方法论）`，编程语言的思想正是建立在`编程范式`之上。最常见的`编程范式`分别是`面向对象程序设计`、`命令式程序设计`、`函数式程序设计`。<br>
&emsp;&emsp;`函数式编程`思想更接近于`面向过程设计`，`面向过程程序设计`就是将复杂的任务分解为简单的任务，通过一层层的调用来完成任务目标，这种分解过程就是`面向过程程序设计`，其中`函数`是`面向过程程序设计`的基本单元。<br>
&emsp;&emsp;`函数式编程`就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，只要输入是确定的，输出就是确定的。<br>
&emsp;&emsp;`函数式编程`的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数。<br>
&emsp;&emsp;其中`λ表达式`是其重要的特性，将函数代码块抽离作为方法参数或返回值对象。<br>

### 1.6.2. 函数式接口

&emsp;&emsp;Java 平台在 java 8 中引入`lambda`表达式，提供了一些`函数式编程`的特性。`函数式接口`则是为`方法引用（::）`和`lambda`表达式提供了目标类型。

- 函数式接口介绍
  - 函数式接口是指仅仅只包含一个抽象方法的接口，为 lambda 表达式和方法引用提供目标类型。
  - 每个函数式接口都有一个单独的抽象方法，称为函数式接口的功能方法，这个抽象方法的参数和返回类型与 lambda 表达式的参数和返回类型相对应。
  - 使用@FunctionalInterface 注解修饰的类，编译器会检测到该类是否只有一个抽象方法或接口，否则会报错。
  - `default`方法不算抽象方法,所以你也可以给你的函数式接口添加多个默认方法和静态方法。
  - 函数式接口能在多种上下文场景中提供所需的目标类型，比如赋值上下文、方法调用或转换上下文。

### 1.6.3. Lambda 表达式

&emsp;&emsp;在 java 中对数据的处理都是依赖于对象的属性和行为，而函数式编程，则直接面向函数进行编程，将对象的行为进行抽象，将方法作为参数进行传递。<br>
&emsp;&emsp;lambda 表达式是 java 8 中引入的新特性，提供了对`函数式编程`的轻度支持，旨在为开发者提供方便，提高开发效率。<br>

- 什么是 lambda 表达式？

  > 我们知道在 Java 中除了 8 大基本数据类型外其它都是引用数据类型也就是我们所说的对象，对于数据的处理是依赖于对象的属性和行为。<br>
  > 在 Java 中的抽象概念都是对于数据进行抽象，而 Lambda 表达式提供了一种对对象的行为进行抽象的一种编程模型，将方法作为参数进行传递。</br>
  > Lambda 表达式的引入将 Java 传统的面向对象编程进行了扩展，提供了以中新的“函数式编程”模型，两者进行结合能够更加有效地帮助我们管理程序的复杂性。<br>

- lambda 的概念定义：
  - 对对象的行为进行抽象，将方法作为参数进行传递；
  - lambda 表达式是一种可传递的匿名函数，简单来说，这是一种没有声明的方法（没有访问修饰符，返回值声明和名称，有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。）。
    - 可传递：Lambda 表达式可以作为参数传递给方法或存储在变量中；
    - 匿名：没有明确的函数名称；
    - 函数：Lambda 表达式是函数，和其它方法一样有参数列表、函数主体、返回类型、还可能有可以抛出的异常列表，但是不像其它方法那样属于某个特定的类；
    - 简洁：无需像匿名类那样写很多模板代码。
  - 该匿名函数并非独立执行，而是用于实现由函数式接口定义的唯一抽象方法，使用 Lambda 表达式时，会创建实现了函数式接口的一个匿名类实例；
  - 可以将 Lambda 表达式视为一个对象，可以将其作为参数传递。

## 1.7. Java 是函数式语言吗？

> java 提供了对函数式编程的轻度支持，但是 Java 的语言特性决定了它不可能成为函数式语言。

    * Java没有结构类型，因此没有“真正的”函数类型。每个`lambda`表达式都会自动转换成适当的名义类型（函数式接口实现类）。
    * 类型擦除在函数式编程中会导致问题——高阶函数的类型安全性会丢失。
    * Java天生可改变，一般认为，可变性是函数式语言极不需要的特性。

## 1.8. 使用注意

- 使用`lambda`表达式会创建实现了函数式接口的一个匿名类实例，但是无法访问接口的默认方法，Lambda 表达式只能去匹配对应接口中的唯一抽象方法。相当于 Lambda 表达式只是对抽象方法的实现，并没有创建接口的实现类对象，因为我们只是想使用这个抽象方法的实现。

## 1.9. Stream 流处理

## 1.10. META-INF 目录

### 1.10.1. META-INF/service 目录

&emsp;&emsp;这个目录主要是`SPI`串行外设接口的类声明。<br>
&emsp;&emsp;我们知道在 java-1.6 和 JDBC-4.0 以后不再需要专门使用`Class.forName("drivePath")`进行数据库驱动的加载，因为在此后的版本驱动包中都提供了`META-INF/service/java.sql.Driver`文件进行驱动类的自动加载。
&emsp;&emsp;Java 应用程序在启动时依赖 jar 包会自动查找`META-INF/service`目录下的文件进行相关类的加载初始化操作。

## 1.11. 值传递和引用传递
