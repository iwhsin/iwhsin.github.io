# 1. JVM 专题

## 基础概念

<!-- panels:start -->
<!-- div:title-panel -->
# Git 基本介绍和配置
![](/docs/assets/images/interview-jvm/20220303102958.png ':size=80% :class=img-center')
<!-- panels:end -->


### 说一下 JVM 的内存结构?

- **JVM 内存结构划分**<br>
&emsp;&emsp;`JVM`内存主要有`虚拟机栈`、`本地方法栈`、`方法区`、`堆`和`程序计数器`五块,其中`虚拟机栈`、`本地方法栈`、`程序计数器`是线程私有的，而`堆`和`方法区`是线程共享的。

- **堆（Heap）**
    - 占用空间最大，Java 中垃圾回收主要区域，采用分代收集算法进行回收。
    - 主要存放线程共享的实例对象，几乎所有的实例独享都是在堆中存放的，随着技术更新，栈上分配、标量替换等优化技术使得对象不一定在堆上进行分配。
    - 堆区分了新生代和老年代，新生代又分为：Eden 空间、From Survivor（S0）空间、To Survivor（S1）空间

- **虚拟机栈（JVM Stacks）**
    - 线程私有，生命周期与线程相同
    - 栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构
    - 存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息

- **本地方法栈**
    - 本地方法栈是为虚拟机使用到的Native方法服务

- **程序计数器**
    - JVM 内存中占用空间最小的一块，同时也是线程私有的，它是唯一没有 OutOfMemoryError 异常的区域。
    - 程序计数器的作用可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变计数器的值来选取下一条字节码指令。其中，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器来完成。
    - 为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

- **方法区**
    - 方法区与堆有很多共性：线程共享、内存不连续、可扩展、可垃圾回收，同样当无法再扩展时会抛出 OutOfMemoryError 异常
    - 方法区中主要存储的是已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

> [!NOTE]
> 可以参考：[JVM 内存结构](docs/principle/jvm/jvm-memory-structure)


## 1.1. 类与类加载器
&emsp;&emsp;jvm中，确定一个类的唯一性是依赖于加载这个类的类加载器和这个类本身的。只有加载类的类加载器和类本身两者都一致，jvm才会认为这个类是唯一的。

### 1.1.1. 类加载器的分类
- JVM层面分类
    - 启动类加载器（Bootstrap ClassLoader）,由C++语言实现，属于JVM内部。
    - 其他的类加载器,由java语言编写，属于JVM外部，全部继承于抽象类java.lang.ClassLoader

- Java层面分类
    - 启动类加载器（Bootstrap ClassLoader）;
    - 扩展类加载器（Extension ClassLoader）:负责加载<JAVA_HOME>\lib\ext 目录中的，或者被java.ext.dirs系统变量所指定的路径下的类库。
    - 应用程序加载器（Application ClassLoader）:该加载器是ClassLoader中的getSystemClassLoader()方法的返回值，一般也称为系统类加载器,负责加载用户类路径CLASSPATH所指定的类库。
    
### 1.1.2. JVM中类加载机制
&emsp;&emsp;JVM中类的装载主要是由`ClassLoader`及其子类来实现的。<br>
&emsp;&emsp;`ClassLoader`是负责在运行时查找和装入类文件的类，

#### 1.1.2.1. 双亲(父亲)委派机制
&emsp;&emsp;java中存在3种类型的类加载器：引导类加载器，扩展类加载器和系统类加载器。三者是的关系是：引导类加载器是扩展类加载器的父类，扩展类加载器是系统类加载器的父类。

- **引导类加载器（Bootstrap）**<br>
&emsp;&emsp;主要负责加载jvm自身所需要的类，该加载器由C++实现，加载的是 <JAVA_HOME>/lib 下的class文件，或 -Xbootclasspath 参数指定的路径下的jar包加载到内存中，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类。

- **拓展类加载器(Extension)**<br>
&emsp;&emsp;扩展类加载器是指Sun公司(已被Oracle收购)实现的 sun.misc.Launcher$ExtClassLoader 类，由Java语言实现的，是Launcher的静态内部类，它负责加载 <JAVA_HOME>/lib/ext 目录下或者由系统变量 -Djava.ext.dir 指定位路径中的类库，开发者可以直接使用标准扩展类加载器。

- **系统类加载器（Application）**<br>
&emsp;&emsp;也称应用程序加载器是指Sun公司实现的 sun.misc.Launcher$AppClassLoader 。它负责加载系统类路径 java -classpath 或 -D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过 ClassLoade.getSystemClassLoader() 方法可以获取到该类加载器

### 1.1.3. 双亲委派模型的工作过程是
&emsp;&emsp;如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（他的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

### 1.1.4. 为什么使用双亲委派机制
&emsp;&emsp;在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，需要注意的是，Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式即把请求交由父类处理，它一种任务委派模式。

- **JVM中如何判断两个对象属于同一个类**
    - 用同名的类完成实例化的；
    - 两个实例各自对应的同名的类的加载器必须是同一个。比如两个相同名字的类，一个是用系统加载器加载的，一个扩展类加载器加载的，两个类生成的对象将被jvm认定为不同类型的对象。
    
- **目的**<br>
&emsp;&emsp;防止重复加载同一个 .class 。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
&emsp;&emsp;为了系统类的安全，类似“ java.lang.Object”这种核心类，jvm需要保证他们生成的对象都会被认定为同一种类型。即“通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的”。<br>
&emsp;&emsp;保证核心 .class 不能被篡改。通过委托方式，不会去篡改核心 .clas ，即使篡改也不会去加载，即使加载也不会是同一个 .class 对象了。不同的加载器加载同一个 .class 也不是同一个 Class对象。这样保证了 Class 执行安全。

### 1.1.5. 类加载器和双亲委派模式的关系
首先我们来看看如果不用双亲委派模式，会是什么结果。比如我们自己创建了一个java.lang.Object类，并且放在classpath下，然后启动程序，因为java本身会有个java.lang.Object类，然后会造成java本身的Object类由启动类加载器来加载，而我们自己创建的Object类会由应用程序类加载器类加载，然后根据我们前面提到的【一个类的唯一性由加载这个类的类加载器和这个类本身来确定】，那么现在这种情况，就会造成类的混乱。而使用双亲委派模式的话，会进行限制，这种情况如果我们自己创建了一个java.lang.Object类，则会在运行时发生错误，限制了类混乱的问题。

### 1.1.6. `Class.forName(String className)`和`ClassLoader.loadClass(String name)`的区别.
&emsp;&emsp;这两种方式都可以进行类的加载，并且都遵循了`双亲委派`机制，区别在于`forName()`默认会进行类的初始化操作，进行静态变量的负责和静态代码块的执行；
&emsp;&emsp;`loadClass()`只进行了类的加载，未进行初始化操作，在使用类的时候才进行初始化操作，加载静态变量和静态代码块。

### 1.1.7. 问题总结
#### 1.1.7.1. 如何自己写一个java.lang.System类？
&emsp;&emsp;为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，自己写的System类根本没有机会得到加载。<br>
&emsp;&emsp;但是，我们可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器加载一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。
扩展点：
    java提供了endorsed技术，可以覆盖jdk中的某些类，具体做法是….。但是，能够被覆盖的类是有限制范围，反正不包括java.lang这样的包中的类<br>
    参考Tomcat的`Bootstrap`类
    
## 1.2. GC-垃圾回收
&emsp;&emsp;Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有"作用域"的概念，只有对象的引用才有"作用域"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。<br>
&emsp;&emsp;回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

### 1.2.1. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？ 
对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

### 1.2.2. java中会存在内存泄漏吗，请简单描述
所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象编程了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。由于Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的，例如下面的代码可以看到这种情况的内存回收：

## JVM虚拟机
&emsp;&emsp;`JVM（Java Virtual Machine）`虚拟机是一个应用程序，提供了运行Java程序所需的运行时环境。如果某个硬件和操作系统平台没有相应的JVM，就不能运行Java程序。<br>
&emsp;&emsp;执行`java <arguments> <program name>` 命令会在操作系统的一个进程中启动JVM。
- `JVM`虚拟机提供了什么用处？
    1. 提供一个容器，让应用程序代码运行在其中；
    2. 较`C/C++`，提供了一个安全的执行环境；
    3. 帮助代开发者管理内存；
    4. 提供一个跨平台的执行环境;
    4. JVM使用运行时信息进行自我管理。
### 运行在`JVM`中的语言

&emsp;&emsp;理论上，`JVM`虚拟机能运行任何有效的类文件，除了 Java 程序能运行在`JVM`虚拟机中，像`Groovy`、`Scala`、`Kotlin`、`Clojure`等也都可以运行在`JVM`虚拟机中。

- 其它语言在`JVM`中的运行方式，主要通过两种方式运行。
    1. 第一种，提供用于生成类文件的源码编译器（类似于javac），以类似Java代码的方式在JVM中运行（Scala等语言采用的是这种方式）。
    2. 第二种可以使用Java实现解释器和运行时，然后解释该语言使用的源码格式。JRuby等语言采用的就是这种方式。

## Java程序生命周期
&emsp;&emsp;Java 程序的生命周期首先从Java 源码开始的，通过`javac`编译后转换为字节码文件（.class），再经过`JVM`虚拟机中的解释器将字节码解释为机器码运行。

### 字节码是什么？
&emsp;&emsp;Java 中的 **字节码** 是以`.class`结尾的特殊的类文件。是处于 **源码** 和 **机器码** 之间的`中间表现形式`。通过`javac`编译器将 **源码** 编译为 **字节码**，再提供给`JVM`虚拟机进行高效解释执行。<br>
&emsp;&emsp;**字节码** 是与设备无关的，不管哪种设备，生成的字节码都是一样的，其中也包括设备使用的字节顺序。

### 操作码（指令码）是什么？
&emsp;&emsp;指令码（操作码）只占一个字节（有些操作还可以有参数，即跟随其后的字节流），所以只有256个可用的指令。实际上，有些指令用不到，大概只会使用200个，而且其中还有一些是最新版javac不支持的。

### `javac`是编译器吗？
&emsp;&emsp;**编译器** 一般指的是将源码进行编译生成机器码，而`javac`并不算完整的编译器，只是将 java 源码编译为中间文件 `字节码`，再由`JVM`虚拟机中的解释器（JIT）进一步编译成机器码进行解释执行。

- 在 Java 语言中将编译分为两部分，分别为`前端编译` 和 `后端编译`。
    1. **前端编译**：将源码编译为`字节码`文件。`javac`执行的就是这一步操作，又称为 `源码编译`。
    2. **后端编译**：将 `字节码` 进一步编译成机器码，进行解释执行。`JVM`虚拟机中的解释器（JIT）就是执行的这一步操作。

### Java语言是解释性语言吗？
- 什么是解释性语言？<br>
&emsp;&emsp;我们都知道计算机只能理解机器语言，而高级语言编写的程序若要被计算机进行执行，必须要先将高级语言翻译为机器语言，再由计算机进行执行，而翻译的形式一般有两种：`解释` 和 `编译`。<br>
&emsp;&emsp;在 Java 语言中，`JVM`虚拟机基本上算是解释器（JIT编译大大提升了性能）。而`JVM`解释执行的是`字节码`，需要先用`javac`将源码编译为`字节码`。因此，可以看出 Java 并不完全算是解释性语言。<br>
&emsp;&emsp;常见的解释性语言有`python`、`javascript`等，在程序运行时，边解释边执行，执行效率较低，而且解释性语言的运行结果可能会受到环境的影响（比如`python2`和`python3`）。