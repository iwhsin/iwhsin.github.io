# 1. 线程安全

## 1.1. 多线程又是怎么实现的?

- **什么是多线程？**<br>
  &emsp;&emsp;多线程（multit-hread），是指从软件或者硬件上实现多个线程并发执行的技术，采用并发执行机制来实现。<br>
  &emsp;&emsp;主要是利用`CPU`处理器的分时机制将程序`执行时间`分为若干个时间片段，每个时间片段轮流执行各个任务，由于时间片段很短，相对于一个应用程序来说，就好像是处理器在为自己单独服务一样，从而达到多个应用程序在同时进行的效果。

- **多线程有什么优势？**
  1. **资源利用率提升，程序处理效率提高**
     1. 单核 CPU，利用处理器的分时机制，通过将时间片段分配到不同的线程，由于时间片段很短，线程切换比较快，因此看起来像过个线程同时执行的结果。
     2. 多核 CPU，通过多线程机制，将不同的 CPU 的时间片段分配到多个线程，达到充分利用多核 CPU 的利用，同时也提升了程序运行效率。
  2. **防止阻塞**
     1. 对于单核 CPU 上使用多线程，相对来说并没有对程序进行多大提升，反而由于线程上下文切换导致了额外的资源消耗，但是单核 CPU 还是要应用多线程技术的，因为在线程执行过程中，如果使用单个线程在处理过程中卡死，则会导致整个应用程序都会阻塞，多线程则很好的降低了这一影响。

## 1.2. 并发编程

- 概述
  - 并发编程的目的是为了让程序运行得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行。
  - 在多线程技术的使用过程中可能会面临诸如上下文切换、线程死锁、资源限制等问题。

### 1.2.1. 上下文切换

- 概述
  - 多线程这个机制是依赖于 CPU 通过给每个线程分配时间片来实现的，时间片是 CPU 分配给各个线程的时间；
  - CPU 通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms），CPU 通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务；
  - 任务切换时会保存上一个任务的执行状态，以便下一次切换回这个任务时，可以再加载这个任务的状态，所以任务从保存到再加载的过程就是一次上下文切换。

- 减少上下文切换
  - 无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁
  - CAS 算法：Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。
  - 使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。
  - 使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

## 1.3. 线程安全问题

- **非线程安全**

  - **多个线程对同一个实例对象中同一实例变量进行操作时出现值被更改**,值不同步的情况进而影响程序的执行过程
  - 非线程安全容易出现脏读(读取到的数据是被更改过的)
  - 对于方法中的局部变量是不会出现非线程安全的,只对实例变量会出现非线程安全

- **线程安全问题**

  - synchronize 关键字 :在多个线程同时调用 run 方法的时候会判定 run 方法是否上锁,此处的锁都是对象锁而不是把一段代码或方法当做锁
  - 多个线程访问同一个对象的同步方法,哪个对象先占对象锁,则先执行完成
  - 多线程可以异步调用非同步方法
  - 数据脏读
  - 加锁的代码块称为互斥区或临界区

- **变量访问**
  &emsp;&emsp;非线程安全主要是多个线程对同一实例对象的同一实例变量进行操作导致的值的改变。 - 局部变量<br>
  &emsp;&emsp;局部变量是线程私有的，在多线程并发访问时不会导致非线程安全问题。

      - 实例变量（本地变量）<br>
      &emsp;&emsp;实例变量是所有线程共享的，在多线程并发访问操作时容易出现值的脏读。

- **线程死锁**<br>
  &emsp;&emsp;多个线程存在锁的互相持有或者线程未能正确释放锁资源导致新的线程获取不到锁导致`死锁`的产生。<br>
    - 代码示例：
        ```java
        private void deadLock() {
            Thread t1 = new Thread(new Runnable() {
                @Override
                public void run() {
                    synchronized (A) {
                        try {
                            Thread.sleep(2000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        synchronized(B) {
                            System.out.println("1");
                        }
                    }
                }
            });
            Thread t2 = new Thread(new Runnable() {
                @Override
                public void run() {
                    synchronized (B) {
                        synchronized (A) {
                            System.out.println("2");
                        }
                    }
                }
            });
            t1.start();
            t2.start();
            }
        ``` 
    - 避免死锁： 
        - 避免一个线程同时获取多个锁 - 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源 - 尝试使用定时锁，使用 lock.tryLock（timeout）来替代使用内部锁机制
