# 1. 接口类型

## 1.1. 标记接口

&emsp;&emsp;有时候定义一个空接口是很有用的，可以帮助我们为对象提供额外的信息，比如我们定义一个空接口，在需要的地方实现它，这样所有实现此接口的类对象都是此接口的实例对象，而且不用实现任何方法，在一些特殊场景中是很有用的。

- **Java 中的标记接口**
  - `java.io.Serializable`：序列化接口就是一种标记接口，实现此接口表示这个类可以进行序列化和反序列操作。
  - `java.lang.Cloneable`：克隆接口，实现此接口表明`Object#clone()`方法可以对该类实例进行按字段复制。

## 1.2. 接口的默认方法

&emsp;&emsp;接口的默认方法是在`Java 8`中引入的，也就是在接口中可以拥有实现的方法了。<br>
&emsp;&emsp;java 平台在发展中始终关注着向后兼容，这个原则让开发团队坚信，升级 JDK 和 JRE 会不会破坏现有程序的运行。我们知道在成型的接口中增加新的方法，对于原有实现此接口的类是不友好的，不能适应原有的程序。在 java 8 中引入了`Lambda表达式`和`函数式接口`，同时也提供了`流处理机制`，需要对 java 核心中的集合类库进行升级。<br>
&emsp;&emsp;为此需要一种新的机制，这种机制需要允许向现有的接口添加可选的新方法，同时又不破坏向后的兼容性。

- 实现默认方法：
  - 在接口中添加新方法而不破坏向后兼容性，这需要为接口的旧实现提供一些新实现，以便接口能继续使用。这个机制是默认方法，在`Java 8`中首次添加到 Java 平台。
  - 看下 java 8 中一个示例：在`java.util.List`接口中增加了一个默认的`sort`方法实现
  ```java
  default void sort(Comparator<? super E> c) {
      Object[] a = this.toArray();
      Arrays.sort(a, (Comparator) c);
      ListIterator<E> i = this.listIterator();
      for (Object e : a) {
          i.next();
          i.set((E) e);
      }
  }
  ```

* **默认方法的基本特性**
  - 实现接口的类可以（但不是必须）实现默认方法；
  - 如果实现接口的类实现了默认方法，那么使用这个类中的实现；
  - 如果找不到其他实现，就使用默认实现。
