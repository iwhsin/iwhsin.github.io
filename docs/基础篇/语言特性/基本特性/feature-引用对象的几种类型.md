# 1. Java 中几种引用对象的引用类型

## 2. 强引用

&emsp;&emsp;强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。

## 3. 软引用

&emsp;&emsp;软引用（soft reference）在强度上弱于强引用，通过类 SoftReference 来表示。它的作用是告诉垃圾回收器，程序中的哪些对象是不那么重要，当内存不足的时候是可以被暂时回收的。<br>
&emsp;&emsp;当 JVM 中的内存不足的时候，垃圾回收器会释放那些只被软引用所指向的对象。如果全部释放完这些对象之后，内存还不足，才会抛出 OutOfMemory 错误。软引用非常适合于创建缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。

## 4. 弱引用

&emsp;&emsp;在强度上弱于软引用，通过类 WeakReference 来表示。它的作用是引用一个对象，但是并不阻止该对象被回收。如果使用一个强引用的话，只要该引用存在，那么被引用的对象是不能被回收的。<br>
&emsp;&emsp;弱引用则没有这个问题。在垃圾回收器运行的时候，如果一个对象的所有引用都是弱引用的话，该对象会被回收。<br>
&emsp;&emsp;弱引用的作用在于解决强引用所带来的对象之间在存活时间上的耦合关系。弱引用最常见的用处是在集合类中，尤其在哈希表中。哈希表的接口允许使用任何 Java 对象作为键来使用。当一个键值对被放入到哈希表中之后，哈希表对象本身就有了对这些键和值对象的引用。如果这种引用是强引用的话，那么只要哈希表对象本身还存活，其中所包含的键和值对象是不会被回收的。如果某个存活时间很长的哈希表中包含的键值对很多，最终就有可能消耗掉 JVM 中全部的内存。<br>
&emsp;&emsp;对于这种情况的解决办法就是使用弱引用来引用这些对象，这样哈希表中的键和值对象都能被垃圾回收。Java 中提供了 WeakHashMap 来满足这一常见需求。

## 5. 虚引用

&emsp;&emsp;在介绍幽灵引用之前，要先介绍 Java 提供的对象终止化机制（finalization）。在 Object 类里面有个 finalize 方法，其设计的初衷是在一个对象被真正回收之前，可以用来执行一些清理的工作。因为 Java 并没有提供类似 C++的析构函数一样的机制，就通过 finalize 方法来实现。但是问题在于垃圾回收器的运行时间是不固定的，所以这些清理工作的实际运行时间也是不能预知的。幽灵引用（phantom reference）可以解决这个问题。在创建幽灵引用 PhantomReference 的时候必须要指定一个引用队列。当一个对象的 finalize 方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了。
&emsp;&emsp;幽灵引用及其队列的使用情况并不多见，主要用来实现比较精细的内存使用控制，这对于移动设备来说是很有意义的。程序可以在确定一个对象要被回收之后，再申请内存创建新的对象。通过这种方式可以使得程序所消耗的内存维持在一个相对较低的数量。比如下面的代码给出了一个缓冲区的实现示例
