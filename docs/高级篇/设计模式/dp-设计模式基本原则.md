# 1. 设计模式基本原则
&emsp;&emsp;`设计模式（Design Pattern）`是软件开发人员在软件开发过程中遇到的一般问题的解决方案，是代码设计的总结，为软件开发设计提供了总体指导思路和参照模板，代表了设计的最佳实践。

## 1.1. 基本原则
> 设计模式的基本原则也是面向对象设计的设计准则，主要有以下几种。
- 开闭原则（总纲）-OCP
- 单一职责原则-SRP
- 里氏替换原则-LSP
- 依赖倒置原则-DIP
- 接口隔离原则-ISR
- 迪米特法则（最少知识原则）-LKP
- 合成复用原则-CRP

### 1.1.1. 开闭原则-OCP
&emsp;&emsp;`开闭原则`是设计模式基本原则的总纲，通过此原则可以保证系统代码复用性和可维护性。<br>

- **定义**：软件系统中的实体（类、模块、函数等）应该`对扩展开放`，`对修改封闭`。
    - **对扩展开放**<br>
    &emsp;&emsp;可以通过扩展已有的软件系统，提供新的功能以满足新的需求，保证变化中的软件系统具有一定的适应性和灵活性。
    
    - **对修改关闭**<br>
    &emsp;&emsp;对于软件系统中已有的模块功能，特别是抽象层（高层）模块不能再修改，保证变化中的软件系统具有一定的稳定性和延续性。

- **实践总结**
    - 抽象约束
    - 元数据控制模块行为
    - 系统开发规范约束
    - 封装变化

### 1.1.2. 单一职能原则（SRP：Single responsibility principle）
&emsp;&emsp;单一职责原则(SRP：Single responsibility principle)又称单一功能原则。<br>
&emsp;&emsp;单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。

- **定义**：一个接口或类有且仅有一个原因引起类的变更。

- **优点**
    - 类的复杂性降低，实现什么职责都有清晰明确的定义，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多;
    - 复杂性降低->可读性提高，可维护性提高;
    - 变更引起的风险降低，单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响，单一原因导致的变更尽可能避免了其它接口模块，业务场景的变动。
    
- **功能设计原则**
    - 一个类实现的功能和作用要单一，比如实体类实现的是单纯的属性和get，set方法，是为了能生成一个纯净的类。
    - 实现逻辑操作的要重新生成一个类，不要在实体类中给出复杂业务逻辑的操作。
    - 调用到业务逻辑的服务操作也要重新生成一个类，边界尽量清晰。

- **软件实体设计原则**
    - 接口角度: 一定要做到单一职责，一个接口只负责一种职责。
    - 类角度: 设计尽量做到只有一个原因引起变化。
    - 方法角度: 一个方法尽可能只做一件事情，比如一个方法'修改用户姓名'，不要把这个放在'修改用户信息'方法中。

- **实践总结**<br>
&emsp;&emsp;因为某种原因，某一职责被分化为颗粒度更细的多个职责，遵守单一职责原则，将不同的职责封装到不同的类或模块中，遵循单一职责原则，变更维护过程中单一业务场景变动不会影响到其它业务场景。<br>
&emsp;&emsp;实际项目开发中考虑职责颗粒度过细，会导致类的剧增，给维护带来麻烦，同时也会人为地增加系统的复杂性，需要根据具体开发环境来考虑系统设计。

    - 对于接口：目前设计过程中多数是根据数据库实体进行划分功能接口，业务接口可以按照功能类划分业务服务类接口负责业务功能处理。
    - 对于类：考虑现实项目开发环境，尽可能针对单一模块单一业务功能进行维护;
    - 对于方法：过程中尽可能提供单一职责(颗粒度足够细)，变更维护尽可能不影响其它业务场景;

### 1.1.3. 里氏替换原则（LSP:Liskov Substitution Principle）
&emsp;&emsp;`里氏替换原则`为良好的继承定义了一个规范，让继承的有利因素发挥最大作用，同时减少有弊因素带来的影响。<br>
&emsp;&emsp;`里氏替换原则`是继承复用的基石，只有当衍生类（子类）可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。

- **定义**
    1. 如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以 T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型<br>
    2. 所有引用基类的地方都必须能透明地使用其子类型的对象。

- **回顾继承的利弊**
    - 继承的利端:
        - 子类拥有父类的所有方法和属性，从而可以减少创建类的工作量，提高了代码的**复用性**；
        - 子类不但拥有了父类的所有功能，还可以添加自己的功能，提高了代码的**扩展性**;
        
    - 继承的弊端:
        - 安全性降低：继承是**侵入性**的，只要继承，就必须拥有父类的所有属性和方法；
        - 灵活性降低：降低了代码的灵活性，因为继承时，父类会对子类有一种约束，子类必须拥有父类的属性和方法；
        - 耦合性增高：增强了耦合性，当需要对父类的代码进行修改时，必须考虑到对子类产生的影响，有时修改了一点点代码都有可能需要对大段程序进行重构。

- **基本特性**：子类可以扩展父类的功能，但不能改变父类原有的功能，具体包含4层含义。
    1. **子类必须完全实现父类的方法，但不能覆盖父类的非抽象方法**;
        ``` text
        系统设计时，通常会先进行接口或抽象类设计，然后由子类来实现抽象方法，调用的地方直接传入接口或抽象类，这里使用的就是LSP原则;
        若子类不完全实现父类接口或抽象类的方法，那么子类就不能进行实例化，这个接口或抽象类的设计就毫无存在意义;
        里氏替换原则规定，子类不能覆写(overwrite)父类已经实现的方法，父类中已经实现的方法是一种已定好的规范和契约，随意改变它可能会带来意想不到的错误;
        父类可以有多个子类，在子类中可能有一个特例，在满足子类的功能时，需要修改父类的方法，但是修改父类的方法又会对其它子类造成影响，产生更多意想不到的错误，违背了里氏替换原则，此时可以针对特例子类创建一个新的父类继承原有父类，这样新的父类既具有原有父类的部分功能，又有子类所需要的特殊功能，既满足了特例的需求，又满足了里氏替换原则。
        ```
    2. **子类可以有自己的个性，增加自己特有的方法**;
        ``` text
        子类继承了父类，拥有了父类和方法，同时还可以定义自己有而父类没有的方法。这是在继承父类方法的基础上进行功能的扩展，符合里氏替换原则。
        ```
    3. **当子类的方法重载父类的方法时，方法的前置条件(即方法的形参)要比父类方法的输入参数更宽松，输入参数可以被放大;**
        ``` text
        当子类重载父类方法时(方法名相同，形参被放大(如:Map))，此时当使用子类的实例进行方法调用时，接受参数类型为父类方法类型(HashMap)时会调用父类方法执行;
        反例: 父类参数类型为Map当子类重载父类方法时(方法名相同，形参被缩小(如:HashMap))，此时使用子类示例进行方法调用时，接受参数为子类方法类型(HashMap)时，会直接调用子类的方法，引起程序逻辑的混乱。
        总结: 子类中方法的前置条件必须与父类中被覆写的方法的前置条件相同或者更宽松，在入参满足父类入参的情形下，应该正常执行父类的方法。
        ```
    4. **当子类的方法实现父类的抽象方法时，方法的后置条件(即方法的返回值)要比父类更严格，输出结果可以被缩小。**
        ``` text
        在子类实现父类抽象方法时，返回值类型要比父类返回值小;
        在继承时，子类的方法返回值类型范围比父类的方法返回值类型范围大，在子类重写该方法时编译器会报错。
        ```
       
- **实践总结**
    - 子类可以继承父类的私有方法以外的所有方法和非私有的属性，重写可以覆盖掉父类中同名同参数的方法。
    - 子类可以扩展父类的功能，但不能改变父类原有的功能。
    - java采用的单继承相较于c++的多继承，总体上来看是“利”多于“弊”的。采用里氏替换原则可以让“利”的因素发挥最大的作用，并减少“弊”带来的诸多麻烦。
    - 在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准
    - 子类不能覆写(overwrite)父类已经实现的方法，父类中已经实现的方法是一种已定好的规范和契约，随意改变它可能会带来意想不到的错误

### 1.1.4. 依赖倒置的原则（DIP：Dependence Inversion Principle）
&emsp;&emsp;`依赖倒置原则`是面向接口编程,针对接口编程，不要针对实现编程。

- **定义**
    - 高层模块不应该依赖低层模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖抽象。
    - 面向接口编程(OOD: Object-Oriented Design)。

- **优点**
    - 减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。 
    - 抽象是对实现的约束，对依赖者而言，也是一种契约，不仅仅约束自己，还同时约束自己与外部的关系，其目的是保证所有的细节不脱离契约的范畴，确保约束双方按照既定的契约（抽象）共同发展，只要抽象这根基线在，细节就脱离不了这个圈圈，始终让你的对象做到“言必信，行必果”。

- **高层模块和低层模块（抽象和实现）**:
    - 每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块；
    - 抽象就是指接口或抽象类，两者都是不能直接被实例化的，细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化；
    
- **依赖倒置原则在JAVA中的表现**
    - 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。
    - 接口或抽象类不依赖于实现类。
    - 实现类依赖接口或抽象类。

- **实践总结**
    - 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。
    - 变量的表面类型尽量是接口或者是抽象类。
    - 任何类都不应该从具体类派生。
    - 尽量不要覆写基类的方法。
    - 结合里氏替换原则使用。
    
### 1.1.5. 接口隔离原则（ISR：Interface Segregation Principle）

- **定义**
    - 客户端不应该依赖它不需要的接口。
    - 一个类对另一个类的依赖应该建立在最小的接口上。

- **实践**
    - 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。
    - 也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
    - 在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。

- **设计原则**
    - 接口要尽量小：接口隔离原则拆分接口时，首先必须满足单一职责原则，设计是要有限度，对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。
    - 接口要高内聚：为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系，在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。
    - 定制服务：一个系统或系统内的模块之间必然会有耦合，提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情，设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。
    - 接口设计是有限度的：接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低，这不是一个项目或产品所期望看到的，所以接口设计一定要注意适度。

- **实践总结**<br>
&emsp;&emsp;接口实现的作用越简单越好，最好是只针对某一项相同对象的。<br>
    - 最佳实践:
        - 一个接口只服务于一个子模块或业务逻辑。
        - 通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法。
        - 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理。
        - 了解环境，拒绝盲从。
    - 示例:
        - 接口隔离原则和其他设计原则一样，都需要花费较多的时间和精力来进行设计和筹划，但是它带来了设计的灵活性，让你可以在业务人员提出“无理”要求时轻松应付，贯彻使用接口隔离原则最好的方法就是一个接口一个方法，保证绝对符合接口隔离原则(有可能不符合单一职责原则)；
        - 怎么才能正确地使用接口隔离原则呢？答案是根据经验和常识决定接口的粒度大小，接口粒度太小，导致接口数据剧增，开发人员呛死在接口的海洋里；接口粒度太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。

### 1.1.6. 最小知识原则(迪米特法则)
&emsp;&emsp;`迪米特法则（LOF：Law of Demeter）`，也称为`最少知识原则（LKP：Least Knowledge Principle）`。

- **定义**<br>
&emsp;&emsp;一个对象应该对其他对象有最少的了解。

- **说明**<br>
&emsp;&emsp;迪米特法则其根本思想，是强调了类之间的松耦合，类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说，信息的隐藏促进了软件的复用。<br>
&emsp;&emsp;类之间的调用，最好不要知道被调用者中其他信息，只要知道对应的接口即可。具体如何实现不需要知道，或者越少越好。

- **基本特性**<br>
&emsp;&emsp;迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义。<br>
    1. **只和朋友交流**<br>
    &emsp;&emsp;一个类只和朋友交流，不与陌生类交流，不要出现getA()。getB()。getC()。getD()这种情况(在一种极端的情况下允许出现这种访问，即每一个点号后面的返回类型都相同)，类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK API提供的类除外。
    
    2. **朋友间也是有距离的**<br>
    &emsp;&emsp;迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。
    
    3. **是自己的就是自己的**<br>
    &emsp;&emsp;如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。
    
    4. **谨慎使用Serializable**
    &emsp;&emsp;在一个项目中使用RMI（Remote Method Invocation，远程方法调用）方式传递一个VO（Value Object，值对象），这个对象就必须实现Serializable接口（仅仅是一个标志性接口，不需要实现具体的方法），也就是把需要网络传输的对象进行序列化，否则就会出现NotSerializableException异常。突然有一天，客户端的VO修改了一个属性的访问权限，从private变更为public，访问权限扩大了，如果服务器上没有做出相应的变更，就会报序列化失败。
    
- **设计原则**
    - 迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高，其要求的结果就是产生了大量的中转或跳转类，其要求的结果就是产生了大量的中转或跳转类，同时也为维护带来了难度。
    - 在采用迪米特法则时需要反复权衡，既做到让结构清晰，又做到高内聚低耦合。
    - 迪米特法则要求类间解耦，但解耦是有限度的，除非是计算机的最小单元，原则只是供参考，如果违背了这个原则，项目也未必会失败，这就需要大家在采用原则时反复度量，不遵循是不对的，严格执行就是“过犹不及。

### 1.1.7. 合成复用原则
- **定义**<br>
&emsp;&emsp;软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

## 1.2. 对比和区分
### 1.2.1. 单一职责原则 VS 接口隔离原则
- **接口隔离原则和单一职责原则的区别**
    - 单一职责原则原注重的是职责，这是业务逻辑上的划分；而接口隔离原则注重对接口依赖的隔离，要求接口的方法尽量少；
    - 单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建

## 1.3. 最佳实践