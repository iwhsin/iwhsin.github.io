# Redis 问题总结

## 缓存和数据库双写一致性问题

- 问题现场<br>
  &emsp;&emsp;在高并发的业务场景下,通常解决数据库层面的压力,引入 Redis 作为缓存层,在涉及数据更新时,不管是先更新数据库,再删除缓存还是先删除缓存再更新数据库都会存在数据不一致的情况. - 先更新数据库,再删除缓存 - 如果数据库更新完成后,服务宕机导致缓存数据未删除则会出现数据不一致的情况 - 先删除缓存,再更新数据库 - 并发访问,先删除缓存,数据库中还未完成写的请求,另一个线程从缓存中访问不到数据,则会从数据库中获取到未更新的数据并重新存入缓存中,这时缓存中的就是脏数据

- 解决方案
  - 延迟双删策略
    - 删除缓存 -> 更新数据库 -> 延迟一段时间(根据业务逻辑完成到缓存更新的耗时确定) -> 删除缓存
    - 弊端
      - 如果在指定延迟时间内超时未更新缓存仍然存在脏数据的问题
      - 延迟指定时间也增加了写请求的耗时
  - 缓存过期
    - 给缓存指定过期时间,是保证最终一致性的解决方案,缓存过期后会自动从数据库中获取最新的数据并缓存
    - 弊端
      - 在缓存未过期前,也是脏数据,根据业务场景来选择
  - 基于订阅 binlog 的同步机制
    - 思想
      - 基于数据库自身的主从备份思想
      - 通过订阅 binlog,在数据库增删改时同步推送订阅消息完成缓存的增量更新
    - 实践
      - 基于阿里的 canal 可以很方便的对 MySQL 的 binlog 进行订阅

## 缓存穿透问题

- 问题现场

  - 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求,最终直接访问到数据库,引起数据库压力瞬间增大

- 解决方案
  - 互斥锁(会降低系统吞吐量)
  - 拦截机制: 通过用户鉴权,key 值校验拦截无效请求,如库 I 用布隆过滤器哦按段 key 是否有效
  - 维护值为 null 的缓存对象并设置过期时间

## 缓存击穿问题

- 问题现场
  - 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力.
- 解决方案
  - 设置热点数据永不过期
  - 使用互斥锁
  - 多级缓存策略

## 缓存雪崩问题

- 问题现场

  - 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机.

- 解决方案
  - 给缓存的失效时间，加上一个随机值，避免集体失效
  - 设置热点数据永远不过期
  - 多级缓存策略。使用多级缓存设置不同的缓存时间, 如 A 缓存指定缓存过期时间, B 缓存永不过期
    - 从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B

## 缓存的并发竞争 Key 问题

- 问题现场

  - 多个线程或系统同时对同一个 Key 进行 Set 操作,则存在 Key 的竞争现象.

- 解决方案
  - 无序更新: 通过互斥锁,多个线程或系统通过竞争锁的形式去完成更新操作
  - 有序更新: 通过版本号或时间撮,在更新时根据前置条件判断是否需要进行更新
