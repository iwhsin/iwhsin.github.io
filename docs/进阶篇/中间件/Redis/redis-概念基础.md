# 1. Redis 概念基础

## 1.1. NoSQL-非关系数据库

- **什么是 NoSQL 数据库?**<br>
  &emsp;&emsp;`NoSQL`数据库泛指`非关系数据库`，区别于`关系型数据库`，它们不保证关系数据的`ACID`特性，是为了解决高并发、高可用、高可扩展，大数据存储等一系列问题而产生的数据库解决方案。<br>

- **常见的 NoSQL 数据库**

  - 键值(Key-Value)存储数据库
  - 列存储数据库
  - 文档型数据库
  - 图形(Graph)数据库

- **NoSQL 数据库的优点**
  - 易扩展<br>
    &emsp;&emsp;NoSQL 数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。
  - 大数据量，高性能<br>
    &emsp;&emsp;NoSQL 数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。
  - 灵活的数据模型<br>
    &emsp;&emsp;NoSQL 无须事先为要存储的数据建立字段，随时可以存储自定义的数据格式。
  - 高可用<br>
    &emsp;&emsp;NoSQL 在不太影响性能的情况，就可以方便地实现高可用的架构。

## 1.2. Redis 概述

&emsp;&emsp;`Redis(Remote Dictionary Server)`是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。

### 1.2.1. Redis 的应用场景

- 点赞/浏览/评论数
- 热点数据缓存
- 数据过期处理（限时业务应用）
- 排行榜
- 基数统计
- 用户行为分析
- 分布式系统 Session 托管

> [!TIP]
> 具体的应用可以参考[Redis 实践应用场景](/docs/进阶篇/中间件/Redis/redis-实践应用场景.md)相关内容。

### 1.2.2. Redis 的优势

- 基于内存存储，读写性能优异，官方测试 Redis 的性能能达到：读的速度是 110000 次/s,写的速度是 81000 次/s
- 丰富的数据类型，支持 string，list，set，Zset，hash 等
- 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
- 支持持久化操作，以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
- 支持数据的备份，即 master-slave 模式的数据备份
- 数据自动过期

### Redis 单线程为何这么快?

- 纯内存操作,基于内存存储和运算
- 单线程运行,避免了线程频繁的上下文切换
- 非阻塞 IO 多路复用避免 IO 层面的性能消耗

## 1.3. Redis 基本数据模型

&emsp;&emsp;Redis 中数据的存储由键-值字典组成，支持多种数据类型的数据存储，区分与其他的非关系型数据库，Redis 中除了能存储字符串外，还支持列表、无序集合、有序集合、哈希。

- String-字符串类型<br>

  - Redis 中存储的最基本的数据类型。
  - 最大可存储`512M`。

- List-字符串列表类型<br>

  - 用于保存元素列表，可以在列表的头部或尾部添加新的元素。
  - 基于双向链表实现（类似于 Java 中的 LinkedList），主要功能有 push、pop、获取一个范围的所有值等
  - 元素最多可以存储`2^32-1`个

- Set-无序不重复的字符串集合<br>

  - 用于保存多个不重复元素的无序集合。
  - 元素最多可以存储`2^32-1`个

- SortedSet-有序集合<br>

  - 用于保存多个不重复元素的有序集合
  - 底层实现是在`Set`基础增加了一个顺序属性，这一属性在添加修改元素的时候可以指定，每个元素会关联一个 double 类型的`score`，根据`score`为集合中的元素排序。
  - 类似于 mysql 数据库中维护了两个字段一个表示元素对象自身的值，另一个维护元素的存储顺序
  - 元素最多可以存储`2^32-1`个

- Hash-哈希<br>
  - 哈希类型是字符串字段和字符串值之间的映射，因此它们是表示对象的理想数据类型，适用于存储对象。
  - 元素最多可以存储`2^32-1`个

> [!TIP]
> 可以参考[Redis 数据结构详解](/docs/进阶篇/中间件/Redis/redis-数据结构详解.md)相关内容。

---

## 1.4. Redis 线程 IO 模型

- Redis 为什么这么快 ß

  - 基于内存存储,所有运算都是内存级别的
  - 单线程运行,不存在线程上下文切换的性能消耗
  - IO 多路复用: 非阻塞 IO 通过系统事件轮询

- Redis 线程模型

  ![](/docs/assets/images/redis-概念基础/20220226231733.png)

### 1.4.1. 非阻塞 IO

&emsp;&emsp;非阻塞 IO 在进行 IO 读写时不会阻塞,读写可以在瞬间完成.

- 非阻塞 IO 进行数据读写时,能读多少读多少,能写多少写多少,不会阻塞等待读取完成/写入完成(不用关新读缓冲区或写缓冲区的状态)

### 1.4.2. 事件轮询(多路复用)

&emsp;&emsp;事件轮询是系统通过`select`、`epoll`、`kqueue`等完成调度的, 系统监控读写缓冲区的状态,在满足条件时通知对应的事件继续完成工作.<br>
&emsp;&emsp;输入是读写描述符列表 read_fds & write_fds，输出是与之 对应的可读可写事件。同时还提供了一个 timeout 参数，如果没有任何事件到来，那么就最多 等待 timeout 时间，线程处于阻塞状态

### 1.4.3. 指令队列

&emsp;&emsp;Redis 会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务

### 1.4.4. 响应队列

&emsp;&emsp;Redis 同样也会为每个客户端套接字关联一个响应队列。Redis 服务器通过响应队列来将 指令的返回结果回复给客户端。 如果队列为空，那么意味着连接暂时处于空闲状态，不需要 去获取写事件，也就是可以将当前的客户端描述符从 write_fds 里面移出来.

### 1.4.5. 定时任务

&emsp;&emsp;Redis 的定时任务会记录在一个称为最小堆的数据结构中。这个堆中，最快要执行的任 务排在堆的最上方。<br>
&emsp;&emsp;在每个循环周期，Redis 都会将最小堆里面已经到点的任务立即进行处 理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是 select 系统调 用的 timeout 参数。<br>
&emsp;&emsp;因为 Redis 知道未来 timeout 时间内，没有其它定时任务需要处理，所以 可以安心睡眠 timeout 的时间

---

## 1.5. Redis 通讯协议

### 1.5.1. Redis 序列化协议-RESP(Redis Serialization Protocol)

&emsp;&emsp;Redis 通过一种直观的文本协议进行数据序列化传输, 实现简单,解析性能好.

- 序列化协议 数据结构
  - 单行字符串 以 + 符号开头
  - 多行字符串 以 $ 符号开头，后跟字符串长度
  - 整数值 以 : 符号开头，后跟整数的字符串形式
  - 错误消息 以 - 符号开头。
  - 数组 以 \* 号开头，后跟数组的长度

## 1.6. Redis 持久化机制

&emsp;&emsp;Redis 中进行持久化操作主要通过`

### 1.6.1. 什么是 RDB ？

&emsp;&emsp;`RDB(Redis DataBase)`持久化操作主要是通过数据快照的形式将某个时间点的全量数据写入到磁盘中的一个临时文件中，在持久化结束后用此文件替换上一次持久化的文件，在 Redis 重启会自动加载此文件，读取备份存储的键值对数据。

- **优点**

  - 只有一个文件 dump.rdb，方便持久化
  - 容灾性好，一个文件可以保存到安全的磁盘
  - 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能)
  - 对比`AOF`在 Redis 服务停机重启时进行数据恢复的效率更高。

- **缺点**

  - 数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)

- 快速原理
  - 为了避免 Redis 主线程发生阻塞, Redis 采用了系统的多进程 COW(Copy On Write)机制来实现快照持久化

### 1.6.2. 什么是 AOF ？

&emsp;&emsp;`AOF(Append-only file)`持久化操作主要是指把内存中的数据序列化为操作请求，通过日志追加的形式保存为`aof`文件。

- **优点**

  - 数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次
  - 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题
  - AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)

- **缺点**
  - AOF 文件比 RDB 文件大，且恢复速度慢 - 数据集大的时候，比 rdb 启动效率低

### AOF的执行过程
同步命令到 AOF 文件的整个过程可以分为三个阶段：
- 命令传播：Redis 将执行完的命令、命令的参数、命令的参数个数等信息发送到 AOF 程序中。
- 缓存追加：AOF 程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的 AOF 缓存中。
- 文件写入和保存：AOF 缓存中的内容被写入到 AOF 文件末尾，如果设定的 AOF 保存条件被满足的话， fsync 函数或者 fdatasync 函数会被调用，将写入的内容真正地保存到磁盘中。

### 1.6.3. 混合持久化

&emsp;&emsp;上述两种持久化操作各有优缺点,使用快照进行数据恢复可能会存在数据丢失的问题,而使用 AOP 指令重放来进行恢复,效率又会慢很多,因此在 Redis 4.0 版本引入了混合持久化的方式,将快照和 AOF 日志文件存在一起,此时的 AOF 中仅存的是自最后一个快照持久化开始到结束这段时间发生的增量 AOP 日志.<br>
&emsp;&emsp;在 Redis 重启恢复时,先加载 rdb 快照中的数据,加载完成后再通过 AOP 日志文件中的指令重放进行数据恢复,既满足了数据恢复的准确性,又显著提升了恢复的效率.

## 1.7. 管道 pipeline

&emsp;&emsp;Redis 中客户端和服务端的每一次命令交互都是一个完成的网络请求, 通过管道可以在同一个网络连接中执行多条指令,降低了网络连接过程中的性能损耗.<br>
&emsp;&emsp;客户端通过对管道中的指令列表改变读写顺序就可以大 幅节省 IO 时间.

- 客户端->服务端请求交互流程
  - 客户端进程调用 write 将消息写到操作系统内核为套接字分配的发送缓冲 send buffer。
  - 客户端操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过「网际路 由」送到服务器的网卡。
  - 服务器操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲 recv buffer。
  - 服务器进程调用 read 从接收缓冲中取出消息进行处理。
  - 服务器进程调用 write 将响应消息写到内核为套接字分配的发送缓冲 send buffer。
  - 服务器操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过「网际路由」送到客户端的网卡。
  - 客户端操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲 recv buffer。
  - 客户端进程调用 read 从接收缓冲中取出消息返回给上层业务逻辑进行处理。
  - 结束。

## 1.8. 事务操作

&emsp;&emsp;Redis 中支持事务操作，允许将一个事务中的多条命令同时执行，执行的结果要么全部成功，要么全部失败。

- **事务执行步骤**

  ```bash
  # 使用`MULTI`开启一个事物
  127.0.0.1:6379> MULTI
  OK
  # 执行操作，每一个操作都存放在一个队列中
  127.0.0.1:6379> INCR t1
  QUEUED
  127.0.0.1:6379> INCR t1
  QUEUED
  127.0.0.1:6379> INCR t1
  QUEUED
  127.0.0.1:6379> get t1
  QUEUED
  # 通过EXEC提交事务执行队列中的操作
  127.0.0.1:6379> EXEC
  1) (integer) 18
  2) (integer) 19
  3) (integer) 20
  4) "20"
  ```

- **事务中断**<br>
  &emsp;&emsp;如果在事务操作过程中，想中断事务中的操作，可以通过`DISCARD`放弃当前事务。

```bash
# 7. 使用`MULTI`开启一个事物
127.0.0.1:6379> MULTI
OK
# 8. 执行操作，每一个操作都存放在一个队列中
127.0.0.1:6379> INCR t1
QUEUED
127.0.0.1:6379> INCR t1
QUEUED
127.0.0.1:6379> INCR t1
QUEUED
127.0.0.1:6379> get t1
QUEUED
# 9. 通过EXEC提交事务执行队列中的操作
127.0.0.1:6379> EXEC
1) (integer) 18
2) (integer) 19
3) (integer) 20
4) "20"
```

### 1.8.1. 原子性

### 1.8.2. discard

### 1.8.3. watch

## 1.9. 发布/订阅

&emsp;&emsp;Redis 中提供了消息的发布/订阅功能支持,对比普通队列而言,可以满足一个消息的多次消费的场景.但是 Redis 不支持消息的持久化操作,因此可能会存在消息丢失的场景,在 Redis 5.0 提供了`Stream`数据结构可以对消息进行持久化操作.

- **基本操作**

  ```bash
  # 订阅一个或多个给定的频道
  ## SUBSCRIBE channel [channel ...]
  127.0.0.1:6379> SUBSCRIBE school.news school.warn
  Reading messages... (press Ctrl-C to quit)
  1) "subscribe"
  2) "school.news"
  3) (integer) 1
  1) "subscribe"
  2) "school.warn"
  3) (integer) 2
  # 发布消息到指定的频道
  ## PUBLISH channel message
  127.0.0.1:6379> PUBLISH school.news 'today is fine.'
  (integer) 1
  ## 频道订阅者获取消息
  127.0.0.1:6379> SUBSCRIBE school.news school.warn
  Reading messages... (press Ctrl-C to quit)
  1) "subscribe"
  2) "school.news"
  3) (integer) 1
  1) "subscribe"
  2) "school.warn"
  3) (integer) 2
  1) "message"
  2) "school.news"
  3) "today is fine."
  ```

- **消息订阅**

  - 指定频道订阅：`SUBSCRIBE channel [channel ...]`
  - 订阅指定模式的频道：`PSUBSCRIBE pattern [pattern ...]`

  ```bash
  # 订阅指定频道
  SUBSCRIBE school.news school.warn
  # 订阅指定模式的频道
  PSUBSCRIBE school.*
  ```

- **系统监控**

  ```bash
  # 查看当前活跃的频道(有客户端通过`SUBSCRIBE`订阅的频道)
  127.0.0.1:6379> PUBSUB CHANNELS
  1) "school.news
  # 查看指定的频道的订阅者数量
  127.0.0.1:6379> PUBSUB NUMSUB school.news school.warn
  1) "school.news"
  2) (integer) 1
  3) "school.warn"
  4) (integer) 0
  # 查看当前被订阅的模式频道的数量总和
  127.0.0.1:6379> PUBSUB NUMPAT
  (integer) 1
  ```

> [!NOTE]
> 消费者断开重连后,在此断开期间的消息将丢失<br>
> Redis 中发布订阅不支持消息的持久化<br>
> Redis 5.0 引入客 Stream 数据结构,可以进行消息的持久化

---

## 1.10. 内存管理

### 1.10.1. 对象压缩

&emsp;&emsp;Redis 如果使用 32bit 进行编译，内部所有数据结构所使用的指针空间占用会少一半.<br>
&emsp;&emsp;如果 Redis 内部管理的集合数据结构很小，它会使用紧凑存储形式压缩存储.

- 存储界限
  ```bash
  hash-max-zipmap-entries 512 # hash 的元素个数超过 512 就必须用标准结构存储
  hash-max-zipmap-value 64 # hash 的任意元素的 key/value 的长度超过 64 就必须用标准结构存储
  list-max-ziplist-entries 512 # list 的元素个数超过 512 就必须用标准结构存储
  list-max-ziplist-value 64 # list 的任意元素的长度超过 64 就必须用标准结构存储
  # zset 的元素个数超过 128 就必须用标准结构存储
  zset-max-ziplist-entries 128
  # zset 的任意元素的长度超过 64 就必须用标准结构存储
  zset-max-ziplist-value 64
  # set 的整数元素个数超过 512 就必须用标准结构存储
  set-max-intset-entries 512
  ```

### 1.10.2. 内存回收机制

&emsp;&emsp;Redis 并不总是可以将空闲内存立即归还给操作系统.

- 内存存储
  - Redis 中数据是以页为单位进行存储的, 如果代回收的键所在的页中仍存在活的对象, 则系统并不会立马回收内存

### 1.10.3. 内存分配算法

&emsp;&emsp;内存分配需要适当的算法划分内存页，需要考虑内存碎片，需要平衡性能和效率.

- 内存分配
  - Redis 中的内存分配直接交给了第三方的内存分配器进行分配;
  - Redis 可以使用 jemalloc/tcmalloc 进行内存分配, 默认使用 jemalloc 内存分配器进行内存管理

## 1.11. 过期策略

&emsp;&emsp;Redis 的复制是异步进行的，wait 指令可以让异步复制变身同步复制，确保系统的强一致性 (不严格).

- 过期 Key 集合

  - redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定时遍历这个字典来删除到期的 key;
  - 删除策略
    - 定时删除(集中处理): 定时扫描过期的 Key 进行集中处理
    - 惰性删除(零散处理): 在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了就立即删除;

- 定时扫描策略<br>
  &emsp;&emsp;Redis 默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略

  - 从过期字典中随机 20 个 key；
  - 删除这 20 个 key 中已经过期的 key；
  - 如果过期的 key 比率超过 1/4，那就重复步骤 1；
    > [!NOTE]
    > 为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms

- 从库过期策略<br>
  &emsp;&emsp;从库不会进行过期扫描，从库对过期的处理是被动的。主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key.

## 1.12. 淘汰策略

&emsp;&emsp;当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)。交换会让 Redis 的性能急剧下降，对于访问量比较频繁的 Redis 来说，这样龟速的存取效率基本上等于不可用.<br>
&emsp;&emsp;生产环境中我们是不允许 Redis 出现交换行为的，为了限制最大使用内存，Redis 提供了配置参数 maxmemory 来限制内存超出期望大小.<br>
&emsp;&emsp;当实际内存超出 maxmemory 时，Redis 提供了几种可选策略 (maxmemory-policy) 来让用户自己决定该如何腾出新的空间以继续提供读写服务.

- 淘汰策略

  - noeviction
    - 禁止驱逐, **默认的淘汰策略**
    - 不进行淘汰处理,服务继续提供读请求,但是不再提供写请求(DEL 请求可以继续服务)
    - 保证了不会丢失数据,但是业务将不能继续进行
  - volatile-lru
    - 从过期 key 列表中淘汰最近最小使用的 Key
    - 没有设置过期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失
  - volatile-ttl
    - 从过期 key 列表中淘汰最近将要过期的 Key
  - volatile-random
    - 从过期 Key 列表中随机淘汰一些 Key
  - allkeys-lru
    - 从所有 Key 中淘汰最近最少使用的 Key 对象
  - allkeys-random
    - 从所有 Key 中随机淘汰一些 Key

- LRU 算法
  - 算法实现
    - 附加链表用于维护元素的访问顺序,链表中的元素按照顺序排序,当空间满的时候,淘汰链表尾部的元素,当某个元素被访问时,将其位置移动到表头.
    - 链表的元素排列顺序就是元素最近被访问的时间顺序.
  - Redis 中考虑到空间的消耗和现有数据结构的改造难度,采用一种近似的 LRU 算法,在每个 Key 中维护了一个额外的字段用于存储 Key 被访问的时间撮
    - 当内存空间超过 maxmemory 时,随机采样出指定个数的 Key(maxmemory_samples 配置,默认为 5),淘汰最旧的 Key,循环操作,直到内存占用低于 maxmemory 为止

---

## 1.13. 主从同步

### 1.13.1. CAP 原理

&emsp;&emsp;CAP 原则又称 CAP 定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾.<br>
&emsp;&emsp;网络分区发生时，一致性和可用性两难全

- CAP 定理
  - 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）
  - 可用性（A）：保证每个请求不管成功或者失败都有响应
  - 分区容忍性（P）：系统中任意信息的丢失或失败不会影响系统的继续运作

### 1.13.2. 最终一致性

&emsp;&emsp;Redis 的主从数据是异步同步的，所以分布式的 Redis 系统并不满足「一致性」要求 Redis 的主从数据是异步同步的，所以分布式的 Redis 系统并不满足`强一致性`要求.

- 数据一致性
  - 客户端在 Redis 的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节 点依旧可以正常对外提供修改服务，所以 Redis 满足「可用性」
  - Redis 保证「最终一致性」，从节点会努力追赶主节点，最终从节点的状态会和主节点 的状态将保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，一旦网络恢 复，从节点会采用多种策略努力追赶上落后的数据，继续尽力保持和主节点一致

### 1.13.3. 主从同步

&emsp;&emsp;Redis 同步支持主从同步和从从同步，从从同步功能是 Redis 后续版本增加的功能，为了减轻主库的同步负担.

![主从同步](/docs/assets/images/redis-概念基础/20220226195431.png)

- 同步方式

  - 增量同步

    ![增量同步](/docs/assets/images/redis-概念基础/20220226195526.png)

    - Redis 同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本 地的内存 buffer 中，然后异步将 buffer 中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一遍向主节点反馈自己同步到哪里了
    - 由于内存 Buffer 的内存是有限的,Redis 的复制内存 buffer 是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容
      > [!NOTE]
      > 因为网络状况不好，从节点在短时间内无法和主节点进行同步，那么当网络状况恢 复时，Redis 的主节点中那些没有同步的指令在 buffer 中有可能已经被后续的指令覆盖掉 了，从节点将无法直接通过指令流来进行同步，这个时候就需要用到更加复杂的同步机制 — — 快照同步

  - 快照同步

    ![快照同步](/docs/assets/images/redis-概念基础/20220226191022.png)

    - 快照同步是一个非常耗费资源的操作，它首先需要在主库上进行一次 bgsave 将当前内存的数据全部快照到磁盘文件中，然后再将快照文件的内容全部传送到从节点
    - 从节点将快照文件接受完毕后，立即执行一次全量加载，加载之前先要将当前内存的数据清空。加载完毕后通知主节点继续进行增量同步
      > [!NOTE]
      > 在整个快照同步进行的过程中，主节点的复制 buffer 还在不停的往前移动，如果快照同步的时间过长或者复制 buffer 太小，都会导致同步期间的增量指令在复制 buffer 中被覆盖，
      > 这样就会导致快照同步完成后无法进行增量复制，然后会再次发起快照同步，如此极有可能会陷入快照同步的死循环

  - 无盘复制<br>
    &emsp;&emsp;主节点在进行快照同步时，会进行很重的文件 IO 操作，特别是对于非 SSD 磁盘存储时，快照会对系统的负载产生较大影响。特别是当系统正在进行 AOF 的 fsync 操作时如果发生快照，fsync 将会被推迟执行，这就会严重影响主节点的服务效率.<br>
    &emsp;&emsp;无盘复制是指主服务器直接通过套接字将快照内容发送到从节点，生成快照是一个遍历的过程，主节点会一边遍历内存，一遍将序列化的内容发送到从节点，从节点还是跟之前一样，先将接收到的内容存储到磁盘文件中，再进行一次性加载.

### 1.13.4. Wait 同步复制

&emsp;&emsp;Redis 的复制是异步进行的，在 Redis 3.0 引入了 wait 指令,可以让异步复制变身同步复制，确保系统的强一致性 (不严格).

---

## Redis 集群

- 集群分片方式
  - 客户端分片
  - 代理分片
    - Twemproxy
    - codis
  - 路由查询分片
    - Redis-cluster
      - 本身提供了自动将数据分散到 Redis Cluster 不同节点的能力，整个数据集合的某个数据子集存储在哪个节点对于用户来说是透明的

### 哨兵(Sentinel)

&emsp;&emsp;Redis Sentinel 是官方提供的一种高可用解决方案, 通过哨兵的方式可以进行故障迁移,自动切换.

- 工作原理
  ![哨兵集群](/docs/assets/images/redis-概念基础/20220226214554.png)

  - 负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换为主节点
  - 客户端来连接集群时，会首先连接 sentinel，通过 sentinel 来查询主节点的地址，然后再去连接主节点进行数据交互
  - 主节点发生故障时，客户端会重新向 sentinel 要地址，sentinel 会将最新的主节点地址告诉客户端

- 节点故障迁移<br>
  ![节点故障迁移](/docs/assets/images/redis-概念基础/20220226214853.png)

  - 从节点被提升为新的主节点，其它从节点开始和新的主节点建立复制关系
  - Sentinel 会持续监控已经挂掉了主节点,等待其恢复

- 节点故障恢复<br>
  ![节点故障恢复](/docs/assets/images/redis-概念基础/20220226215531.png)
  - 原先挂掉的主节点现在变成了从节点，从新的主节点那里建立复制关系

> [!TIP]
> 哨兵模式可以很好的进行故障迁移,但是避免不了的仍是单个 Redis 实例在提供服务,数据也都存储在单个实例上.

### 集群(Cluster)

&emsp;&emsp;Redis Cluster 是 Redis 官方推出的一种集群方案,是去中心化的,通过哈希槽划分数据将数据进行分片存储在不同的节点上,通常结合复制模型,保证系统的高可用.<br>
&emsp;&emsp;Redis Cluster 没有采用一致性哈希算法,而是使用了哈希槽的概念,通过将数据划分为`16384`个哈希槽,进行分片存储.

- 分片原理
  &emsp;&emsp;Cluster 中有一个 16384 长度的槽(虚拟槽)，编号分别为 0-16383。每个 Master 节点都会负责一部分的槽，当有某个 key 被映射到某个 Master 负责的槽，那么这个 Master 负责为这个 key 提供服务，至于哪个 Master 节点负责哪个槽，可以由用户指定，也可以在初始化的时候自动生成，只有 Master 才拥有槽的所有权.<br>
  &emsp;&emsp;Master 节点维护着一个 16384/8 字节的位序列，Master 节点用 bit 来标识对于某个槽自己是否拥有。比如对于编号为 1 的槽，Master 只要判断序列的第二位（索引从 0 开始）是不是为 1 即可。这种结构很容易添加或者删除节点。比如如果我想新添加个节点 D,我需要从节点 A、B、C 中得部分槽到 D 上.

#### 主从复制模型

&emsp;&emsp;为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.<br>
&emsp;&emsp;在节点发生故障时,集群可以自动完成故障迁移将从节点升级为对应的主节点.

### Codis

&emsp;&emsp;Codis 使用 Go 语言开发，它是一个代理中间件，它和 Redis 一样也使用 Redis 协议对外提供服务，当客户端向 Codis 发送指令时，Codis 负责将指令转发到后面的 Redis 实例来执行，并将返回结果再转回给客户端.<br>
&emsp;&emsp;Codis 是无状态的，它只是一个转发代理中间件，这意味着我们可以启动多个 Codis 实例，供客户端使用，每个 Codis 节点都是对等的.

#### 分片原理

&emsp;&emsp;Codis 将所有的 key 默认划分为 1024 个槽位(slot)，它首先对客户端传过来的 key 进行 crc32 运算计算哈希值，再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽位.<br>
&emsp;&emsp;每个槽位都会唯一映射到后面的多个 Redis 实例之一，Codis 会在内存维护槽位和 Redis 实例的映射关系.<br>
&emsp;&emsp;不同的 Codis 实例之间槽位关系通过分布式配置存储数据库专门用来持久化槽位关系,如 Zookeeper/etcd.

---

## 1.14. 扩展介绍

### 1.14.1. Key 值查找

&emsp;&emsp;经常我们需要通过 key 值进行模糊匹配相关的键值列表,可以简单暴力的使用 keys 命令,也可以通过 scan 命令操作游标的形式进行查找.

#### 1.14.1.1. keys

- 命令操作
  ```bash
  keys *
  keys pattenr*
  ```
  - 没有 offset、limit 参数，一次性吐出所有满足条件的 key
  - keys 算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿

#### 1.14.1.2. scan

- 命令操作

  ```bash
  # 从指定游标开始遍历,返回的第一个整数值作为下一次遍历的游标值,直到返回的游标值为0
  scan {cursor} [match {pattern}] [count {limit}]
  ```

  - 参数说明
    - cursor: 指示比阿奶的游标
    - pattern: 指示 key 的规则
    - limit: 指示遍历的字典槽位的数量

- 遍历顺序
  - 是虑到字典的扩容和缩容 时避免槽位的遍历重复和遗漏,采用高位进位加法进行遍历
    > [!TIP]
    > 普通加法和高位进位加法的区别
    > 高位进位法从左边加，进位往右边移动，同普通加法正好相反。但是最终它们都会遍历所有的槽位并且没有重复

> [!NOTE]
> scan 命令可以无阻塞的取回指定模式的 Key 的列表,但是会有一定的重复率,需要在客户端完成去重工作.

### 1.14.2. 虚拟内存

&emsp;&emsp;对于 Key 值比较少但是对应 Key 中 Value 对象占用内存比较大的场景,在设计过程中我们可以把 key 储在内存中（为了保证快速查找），而 value 在很少使用时，可以从内存被交换出至磁盘上.

### 1.14.3. Redis 中 Lua 脚本执行

&emsp;&emsp;通过`EVAL script numkeys key [key ...] arg [arg ...]`可以执行`lua`脚本。<br>
&emsp;&emsp;在`lua`脚本中可以通过`redis.call()`或`redis.pcall()`的方式执行 redis 命令。<br>

- **示例**
  ```bash
  eval "return redis.call('set','foo','bar')" 0
  ```
