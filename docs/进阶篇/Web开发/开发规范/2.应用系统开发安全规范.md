# 1 概述
## 1.1 常见的安全考量范围
> &nbsp;&nbsp;&nbsp;&nbsp;身份验证、会话管理、权限管理、敏感数据保护、安全审计、输入校验、输出编码、上传下载、异常处理、代码注释、归档要求。
## 1.2 安全编码原则
* 程序只实现你指定的功能；
* 永远不要信任用户输入，对用户输入数据做有效性检查；
* 必须考虑意外情况并进行处理；
* 不要试图在发现错误之后继续执行；
* 尽可能使用安全函数进行编程；
* 小心、认真、细致地编程。

## 1.3 应用系统的体系结构和设计问题
<strong>表1 应用系统缺陷和由于不良设计可能导致的问题</strong>
|缺陷类别|由于不良设计可能导致的问题|
|:---|:---|
|身份验证|身份伪造、口令破解、重放攻击、权限提升和未授权访问|
|会话管理|通过捕获导致会话劫持和会话伪造|
|权限管理|访问机密或受限数据、篡改和执行未授权操作|
|配置管理|未授权访问管理界面、更新配置数据、访问用户帐户和帐户配置文件|
|敏感数据|机密信息泄漏和数据篡改|
|加密技术|未授权访问机密数据或帐户信息|
|安全审计|未能识别入侵征兆、无法证明用户的操作，以及在问题诊断中存在困难|
|输入检验|通过嵌入查询字符串、窗体字段、Cookie 和 HTTP 标头中的恶意字符串所执行的攻击包括命令执行、跨站点脚本编写 (XSS)、SQL 注入和缓冲区溢出攻击等|
|参数操作|路径遍历攻击、命令执行、此外还有跳过访问控制机制、导致信息泄露、权限提升和拒绝服务|
|异常管理|拒绝服务和敏感的系统级详细信息泄露|

# 2 应用系统安全控制项
## 2.1 应用系统部署要求
### 2.1.1 常用规则
* 规则1：
    * 如果应用系统对Internet开放，应用系统服务器应当置于DMZ区(隔离区-两个防火墙之间的区域)，在应用系统服务器与Internet之间，应用系统服务器与内网之间应当有防火墙隔离，并设置合理的策略。
* 规则2：
    * 如果应用系统对Internet开放，应用系统服务器应该部署在其专用的服务器上，应避免将数据库服务器或其他核心应用与应用系统服务器部署在同一台主机上。
    * 说明：应用系统服务器比较容易被攻击，如果数据库或核心应用与应用系统服务器部署在同一台主机，一旦应用系统服务器被攻陷，那么数据库和核心应用也就被攻击者掌控了。
* 规则3：
    * 应用系统的根目录必须安装在非系统卷中
    * 说明：应用系统根目录安装在非系统卷，如单独创建一个目录/home/Web作为应用系统根目录，能够防止攻击者使用目录遍历攻击访问系统工具和可执行文件。
### 2.1.2 部署建议
* 建议1:
    * web服务器与应用服务器需物理分离（即安装在不同的主机上），以提高应用的安全性。
* 建议2:
    * 如果应用系统存在不同的访问等级（如个人帐号使用、客户服务、管理），那么应该通过不同的应用系统服务器来处理来自不同访问等级的请求，而且应用系统应该鉴别请求是否来自正确的应用系统服务器。
    * 说明：这样便于通过防火墙的访问控制策略和应用系统来控制不同访问等级的访问，比如通过防火墙策略控制，只允许内网访问管理应用系统。
* 建议3:
    * 对于“客户服务”和“管理”类的访问，除了普通的认证，还应该增加额外的访问限制。
    * 说明：额外的访问限制，可以限制请求来自企业内网，可以建立VPN，或采用双向认证的SSL；或采用更简单的办法，通过IP地址白名单对客户端的IP地址进行过滤判断。
## 2.2 身份验证
### 2.2.1 口令密码管理
#### 2.2.1.1 口令安全策略管理
* 规则1: 检测口令密码的复杂度
    * 必须6位包含大写、小写、数字、特殊符号等满足指定校验规则；
    * 不能包含与账号一样的连续敏感字符。
* 规则2： 设置口令出错阈值
    * 指定重复输入错误口令达到指定次数进行账户锁定操作；
    * 限制下次允许输入口令的间隔时间加倍。
* 规则3： 设置自动解锁时间
    * 对于口令尝试N次失败被锁定的用户，系统能够设置自动解锁时间，建议默认时间为5分钟；
    * 用户被锁时间达到预定义时间，可自动解锁该用户，或者也可通过安全管理员手工解锁该用户；
    * 在锁定时间内，仅能允许应用安全管理员角色所属账号手动解锁该用户。
#### 2.2.1.2 口令安全使用规则
* 规则1： 操作界面中的口令不能明文显示
    * 操作界面中的输入口令可不显示或用*代替；
    * 终端上打印或存储在日志中时也不能明文显示口令；
    * 即使是内存中的明文口令（如登录期间），也应在使用后立即覆盖。
* 规则2： 口令输入框内容禁止拷贝
* 规则3： 缺省口令符合复杂度要求
    * 对于系统内置账号的缺省口令，口令应符合复杂度的要求，并在客户资料中提醒用户修改。
* 规则4： 用户可修改自己的口令
    * 用户修改自己口令时必须验证旧口令；
    * 不允许修改除自身账号以外的账号的口令（管理员除外）。
* 规则5: 口令不能在网络中明文传输
    * 口令等认证凭证在传输过程中必须加密，使用高安全等级的加密算法。
* 规则6: 口令在本地存储时必须加密
    * 口令不能够明文写入日志文件、配置文件以及cookie中;
    * 口令文件必须设置访问控制，普通用户不能读取或拷贝加密的内容。
### 2.2.2  认证
#### 2.2.2.1 认证规则
* 规则1: 对用户的最终认证处理过程必须放到应用服务器进行。
    * 说明：不允许仅仅通过脚本或其他形式在客户端进行验证，必须在应用服务器进行最终认证处理（如果采用集中认证，那么对用户的最终认证就是放在集中认证服务器进行）。
* 规则2: 网页上的登录/认证表单必须加入验证码。
    说明：使用验证码的目的是为了阻止攻击者使用自动登录工具连续尝试登录，从而降低被暴力破解的可能。如果觉得验证码影响用户体验，那么可以在前3次登录尝试中不使用验证码，3次登录失败后必须使用验证码。验证码在设计上必须要考虑到一些安全因素，以免能被轻易地破解。
    备注：对于嵌入式系统，如果实现验证码比较困难，可以通过多次认证失败锁定客户端IP的方式来防止暴力破解。
* 规则3: 用户名、密码和验证码必须在同一个请求中提交给服务器
    * 必须先判断验证码是否正确，只有当验证码检验通过后才进行用户名和密码的检验，否则直接提示验证码错误。
    * 说明：如果验证码和用户名、密码分开提交，攻击者就可以绕过验证码校验（如：先手工提交正确的验证码，再通过程序暴力破解），验证码就形同虚设，攻击者依然可以暴力破解用户名及口令。
* 规则4: 所有登录页面的认证处理模块必须统一。
    * 说明：可以存在多个登录页面，但是不允许存在多个可用于处理登录认证请求的模块，防止不一致的认证方式。
* 规则5: 所有针对其他第三方开放接口的认证处理模块必须统一。
* 规则6: 认证处理模块必须对提交的参数进行合法性检查。
* 规则7: 认证失败后，不能提示给用户详细以及明确的错误原因，只能给出一般性的提示。
    * 说明：可以提示：“用户名或者口令错误，登录失败”；不能提示：“用户名不存在”、“口令必须是 6 位”等等。
* 规则8: 最终用户入口和管理入口分离。
    * 说明：最终用户入口和管理入口分离，防止相互影响，防止来自用户面的攻击影响管理面。
    * 实施指导：将最终用户入口和管理入口分别部署在不同的物理服务器；如果为了解决成本（部署在同一台物理服务器上），那么，必须做到端口分离（通过不同的端口提供应用系统服务）。
* 规则9: 禁止在系统中预留任何的后门帐号或特殊的访问机制
* 规则10: 对于重要的管理事务或重要的交易事务要进行重新认证，以防范会话劫持和跨站请求伪造给用户带来损失。
    * 说明：重要的管理事务，比如重新启动业务模块；重要的交易事务，比如转账、余额转移、充值等。重新认证，比如让用户重新输入口令。
* 规则11: 用户名和密码认证通过后，必须更换会话标识，以防止会话固定（session fixation）漏洞。
#### 2.2.2.2 认证建议
* 建议1: 管理页面建议实施强身份认证
    * 说明：如双因素认证、SSL双向证书认证、生物认证等；还可以通过应用程序限制只允许某些特定的IP地址访问管理页面，并且这些特定的IP地址可配置。
* 建议2: 同一客户端在多次连续尝试登录失败后，服务端需要进行用户帐号或者是客户端所在机器的 IP 地址的锁定策略，且该锁定策略必须设置解锁时长，超时后自动解锁。
    * 说明：
        * 登录失败应该提示用户：如果重试多少次不成功系统将会锁定。在锁定期间不允许该用户帐号（或者客户端所在机器的IP地址）登录。
        * 允许连续失败的次数（指从最后一次成功以来失败次数的累计值）可配置，取值范围为：0-99 次，0表示不执行锁定策略，建议默认：5 次。
        * 锁定时长的取值范围为：0-999分钟，建议默认：30分钟，当取值为0时，表示无限期锁定，只能通过管理员手动解锁（需要提供管理员对服务器锁定其它用户帐号/IP进行解锁的功能界面）。建议优先使用帐号锁定策略。
    * 注意：应用系统的超级用户帐号不能被锁定，只能锁定操作的客户端所在的IP，这是为了防止系统不可用。
    * 特别说明：
        * 锁客户端IP策略存在缺陷，当用户使用proxy上网时，那么锁定客户端IP会导致使用该proxy上网的所有用户在IP锁定期间都不能使用该应用系统；
        * 锁定用户帐户的策略也存在缺陷，当攻击者不断尝试某帐户的口令，就给该帐户带来拒绝服务攻击，使该帐户不可用。
* 建议3：使用密码安全控件
    * 说明：安全控件是一种为了提升账户安全性，防止账户密码等私密信息被木马或病毒窃取的客户端程序，安全控件大多小巧，可以通过ActiveX或者手工下载的方式安装，在用户账户登录等页面提供安全防护。

### 2.2.3 验证码
#### 2.2.3.1 使用规则
* 规则1：验证码必须是单一图片，且只能采用 JPEG、PNG或GIF格式
    * 说明：验证码不能使用文本格式，不允许多图片组合（如用四个图片拼成的验证码）。
* 规则2：验证码内容不能与客户端提交的任何信息相关联
    * 说明：在使用验证码生成模块时不允许接收来自客户端的任何参数，例如：禁止通过getcode.jsp?code=1234的URL请求，将1234作为验证码随机数。
* 规则3：验证码模块生成的随机数不能在客户端的静态页面中的网页源代码里出现
    * 说明：在客户端网页上点击鼠标右键、选择“查看源文件”时，必须看不到验证码模块生成的随机数。
* 规则4：验证码字符串要求是随机生成，生成的随机数必须是安全的
    * 说明：对于java语言可以使用类 java.security.SecureRandom来生成安全的随机数。C/C++中的密码安全随机最简单和安全的方法是，把libsodium库添加到工程的依赖库中，使用randombytes_buf()函数。
* 规则5：验证码要求有背景干扰，背景干扰元素的颜色、位置、数量要求随机变化
* 规则6：验证码在一次使用后要求立即失效，新的请求需要重新生成验证码
    * 说明：进行验证码校验后，立即将会话中的验证码信息清空，而不是等到生成新的验证码时再去覆盖旧的验证码，防止验证码多次有效；注意：当客户端提交的验证码为空，验证不通过。

## 2.3 会话管理
### 2.3.1 使用规则
* 规则1：使用会话cookie维持会话
    * 说明：
        * 目前主流的Web容器通过以下几种方式维持会话：隐藏域、URL重写、持久性cookie、会话cookie，但通过隐藏域、URL重写或持久性cookie方式维持的会话容易被窃取，所以要求使用会话cookie维持会话。
        * 如果条件限制必须通过持久性cookie维持会话的话，那么cookie信息中的重要数据部分如身份信息、计费信息等都必须进行加密。
        * cookie有两种：会话cookie和持久性cookie；
            * 会话cookie，也就是非持久性cookie，不设置过期时间，其生命期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了；会话cookie一般不存储在硬盘上而是保存在内存里。
            * 持久性cookie，设置了过期时间，被浏览器保存到硬盘上，关闭后再次打开浏览器，持久性cookie仍然有效直到超过设定的过期时间。
* 规则2: 会话过程中不允许修改的信息，必须作为会话状态的一部分在服务器端存储和维护
    * 说明：会话过程中不允许修改的信息，例如，当用户通过认证后，其用户标识在整个会话过程中不能被篡改。禁止通过隐藏域或URL重写等不安全的方式存储和维护。对JSP语言，就是应该通过session对象进行存储和维护。
* 规则3：当应用系统跟踪到非法会话，则必须记录日志、清除会话并返回到认证界面
    * 说明： 非法会话的概念就是通过一系列的服务端合法性检测（包括访问未授权资源，缺少必要参数等情况），最终发现的不是正常请求产生的会话。
* 规则4：禁止使用客户端提交的未经审核的信息来给会话信息赋值
    * 说明：防止会话信息被篡改，如恶意用户通过URL篡改手机号码等。
* 规则5：当用户退出时，必须清除该用户的会话信息。
    * 说明：防止遗留在内存中的会话信息被窃取，减少内存占用。
    * 实施指导：对于JSP或java语言使用如下语句：request.getSession().invalidate()。
* 规则6：必须设置会话超时机制，在超时过后必须要清除该会话信息
    * 说明：建议默认会话超时时间为10分钟（备注：对于嵌入式的应用系统，建议默认超时时间为5分钟，以减少系统资源占用）。如果没有特殊需求，禁止使用自动发起请求的机制来阻止session超时。
* 规则7：在服务器端对业务流程进行必要的流程安全控制，保证流程衔接正确，防止关键鉴别步骤被绕过、重复、乱序
    * 实施指导：可以通过在session对象中创建一个表示流程当前状态的标识位，用0、1、2、3、…、N分别表示不同的处理步骤，标识位的初始值为0，当接收到步骤N的处理请求时，
        判断该标识位是否为N-1，如果不为N-1，则表示步骤被绕过（或重复或乱序），拒绝受理，否则受理，受理完成后更改标识位为N。
* 规则8：所有登录后才能访问的页面都必须有明显的“注销（或退出）”的按钮或菜单，如果该按钮或菜单被点击，则必须使对应的会话立即失效
    * 说明：这样做是为了让用户能够方便地、安全地注销或退出，减小会话劫持的风险。
* 规则9：如果应用系统（如嵌入式系统）无法使用通用的Web容器，只能自己实现Web服务
    * 那么必须自己实现会话管理，并满足以下要求
        * 采用会话cookie维持会话；
        * 生成会话标识（session ID）要保证足够的随机、离散，以便不能被猜测、枚举，要求session ID要至少要32字节，要支持字母和数字字符集；
        * 服务端必须对浏览器端提交的session ID的有效性进行校验。
    * 说明：在嵌入式系统中部署Web应用，由于软硬件资源所限，往往无法使用通用的Web容器及容器的会话管理功能，只能自己实现。
        另外，为了节省内存，嵌入式webserver进程往往是动态启动，为了使session更快的超时，建议增加心跳机制，对客户端浏览器是否关闭进行探测，5s一个心跳，30s没有心跳则session超时，关闭该session。

## 2.4 权限管理
### 2.4.1 使用规则
* 规则1：对于每一个需要授权访问的页面或控制器的请求都必须核实用户的会话标识是否合法、用户是否被授权执行这个操作
    * 说明：防止用户通过直接输入URL，越权请求并执行一些页面，建议通过过滤器实现。
* 规则2：授权和用户角色数据必须存放在服务器端，不能存放在客户端，鉴权处理也必须在服务器端完成
    * 说明：禁止将授权和角色数据存放在客户端中（比如cookie或隐藏域中），以防止被篡改。
* 规则3：一个帐号只能拥有必需的角色和必需的权限。一个组只能拥有必需的角色和必需的权限。一个角色只能拥有必需的权限
    * 说明：做到权限最小化和职责分离（职责分离就是分清帐号角色，系统管理帐号只用于系统管理，审计帐号只用于审计，操作员帐号只用于业务维护操作，普通用户帐号只能使用业务。）这样即使帐号被攻击者盗取，也能把安全损失控制在最小的限度。
* 规则4：对于运行应用系统的操作系统帐号，不应使用“root”、“administrator”、“supervisor”等特权帐号或高级别权限帐号，应该尽可能地使用低级别权限的操作系统帐号
* 规则5：对于应用系统连接数据库服务器的数据库帐号，在满足业务需求的前提下，必须使用最低级别权限的数据库帐号
    * 说明：根据业务系统要求，创建相应的数据库帐号，并授予必需的数据库权限。不能使用“sa”、“sysman”等管理帐号或高级别权限帐号。

## 2.5 敏感数据保护
### 2.5.1 敏感数据定义
> &nbsp;&nbsp;&nbsp;&nbsp;敏感数据包括但不限于：口令、密钥、证书、会话标识、License、隐私数据（如短消息的内容）、授权凭据、个人数据（如姓名、住址、电话等）等，在程序文件、配置文件、日志文件、备份文件及数据库中都有可能包含敏感数据。
### 2.5.2 敏感数据存储
#### 2.5.2.1 使用规则
* 规则1：禁止在代码中存储敏感数据
    * 说明：禁止在代码中存储如数据库连接字符串、口令和密钥之类的敏感数据，这样容易导致泄密。用于加密密钥的密钥可以硬编码在代码中。
* 规则2：禁止密钥或帐号的口令以明文形式存储在数据库或者文件中
    * 说明：密钥或帐号的口令必须经过加密存储。例外情况，如果Web容器的配置文件中只能以明文方式配置连接数据库的用户名和口令，那么就不用强制遵循该规则，将该配置文件的属性改为只有属主可读写。
* 规则3: 禁止在 cookie 中以明文形式存储敏感数据
    * 说明：cookie信息容易被窃取，尽量不要在cookie中存储敏感数据；如果条件限制必须使用cookie存储敏感信息时，必须先对敏感信息加密再存储到cookie。
* 规则4：禁止在隐藏域中存放明文形式的敏感数据
* 规则5：禁止用自己开发的加密算法，必须使用公开、安全的标准加密算法
    * 实施指导：
        * 场景 1：服务端保存数据库的登录口令
            * 服务器登录数据库需要使用登录数据库的明文口令，此时服务器加密保存该口令后，下次登录时需要还原成明文，因此，在这种情况下，不建议用不可逆的加密算法，而需要使用对称加密算法或者非对称加密算法，一般也不建议采用非对称加密算法。
            * 推荐的对称加密算法：AES256。
        * 场景 2：服务端保存用户的登录口令
            * 在该场景下，一般情况是：客户端提交用户名及用户口令，服务端对用户名及用户口令进行验证，然后返回验证的结果。此时，在服务端，用户口令可以不需要还原，因此建议使用不可逆的加密算法，对“用户名+口令”字符串进行加密。
            * 推荐的不可逆加密算法： SHA256、SHA384、SHA512，HMAC-SHA256、HMAC-SHA384、HMAC-SHA512。
* 规则6：禁止在日志中记录明文的敏感数据
    * 说明：禁止在日志中记录明文的敏感数据（如口令、会话标识等）， 防止敏感信息泄漏。
* 规则7：禁止带有敏感数据的Web页面缓存
    * 说明：带有敏感数据的Web页面都应该禁止缓存，以防止敏感信息泄漏或通过代理服务器上网的用户数据互窜问题。
    * 实施指导：
        ```
        在HTML页面的<HEAD>标签内加入如下代码：
        <HEAD>
        <META HTTP-EQUIV="Expires" CONTENT="0">
        <META HTTP-EQUIV="Pragma" CONTENT="no-cache">
        <META HTTP-EQUIV="Cache-control" CONTENT="no-cache">
        <META HTTP-EQUIV="Cache" CONTENT="no-cache">
        </HEAD>
        在JSP页面的最前面加入如下代码：
        <%
        response.setHeader("Cache-Control","no-cache");
        response.setHeader("Pragma","no-cache");
        response.setDateHeader("Expires",0);
        %>
        注意：以上代码对于采用强制缓存策略的代理服务器不生效（代理服务器默认是不缓存的），要防止代理服务器缓存页面，可以在链接后加入一个随机数pageid,此时链接变成：http://localhost:8080/query.do?a=2&pageid=2245562, 其中2245562数字是随机生成的，每次请求此页面时，随机数都不同，IE始终认为此为一个新请求，并重新解析，生成新的响应页面。
        ```
### 2.5.3 敏感数据传输
#### 2.5.3.1 使用规则
* 规则1：带有敏感数据的表单必须使用 HTTP-POST 方法提交
    * 说明：禁止使用 HTTP-GET 方法提交带有敏感数据的表单（form），因为该方法使用查询字符串传递表单数据，易被查看、篡改。如果是使用servlet处理提交的表单数据，那么不在doGet方法中处理，只在doPost方法处理。
    * 实施指导：
    ```
    1. 对于JSP页面，将表单的属性method赋值为"post"，如下
        <form name="form1" method="post" action="switch.jsp">
    2. 如果是使用servlet处理提交的表单数据，那么只在doPost方法中处理，参考代码如下
        public class ValidationServlet extends HttpServlet
        {
            public void doPost(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException
            {
                //对提交的表单数据进行校验
            }
        }
    ```
* 规则2：在客户端和服务器间传递明文的敏感数据时，必须使用带服务器端证书的SSL
    * 说明：如果在客户端和服务器间传递如帐号、口令等明文的敏感数据，必须使用带服务器端证书的SSL。由于SSL对服务端的CPU资源消耗很大，实施时必须考虑服务器的承受能力。
* 规则3：禁止在URL中携带会话标识
    * 说明：由于浏览器会保存URL历史记录，如果URL中携带会话标识，则在多人共用的PC上会话标识容易被其他人看到，一旦该会话标识还在其生命有效期，则恶意用户可以冒充受害用户访问应用系统。
* 规则4：禁止将对用户保密的信息传送到客户端。
    * 说明：这些信息一旦传送到客户端，那么用户也就可以获取到了。
## 2.6 安全审计
> 本节的安全审计是针对Web业务应用，不包括对操作系统、Web容器的安全审计。对于操作系统和Web容器的安全审计，可以参考对应的操作系统安全基线和Web安全配置规范。
### 2.6.1 使用规则
* 规则1：应用服务器必须对安全事件及操作事件进行日志记录
    * 说明：安全事件包括登录、注销、添加、删除、修改用户、授权、取消权限、鉴权、修改用户口令等；操作事件包括对业务系统配置参数的修改，对重要业务数据的创建、删除、修改、查询等；对于上述事件的结果，不管是成功还是失败，都需要记录日志。
* 规则2：安全日志必须包括但不限于如下内容
    * 事件发生的时间、事件类型、客户端IP、客户端机器名、当前用户的标识、受影响的个体（数据、资源）、成功或失败标识、启动该事件的进程标识以及对该事件的详细描述。
* 规则3：严格限制对安全日志的访问
    * 说明：
        * 只有应用系统的管理员才能查询数据库表形式或文件形式的安全日志；
        * 除数据库超级管理员外，只有应用程序连接数据库的帐号可以查询（select）及插入（insert）安全日志表；
        * 除操作系统超级管理员外，只有应用程序的运行帐户才能读、写文件形式的安全日志（但不允许删除）。
        * 确保日志的安全，限制对日志的访问，这加大了攻击者篡改日志文件以掩饰其攻击行为的难度。
* 规则4：对日志模块占用资源必须有相应的限制机制。
    * 说明：限制日志模块占用的资源，以防止如自动的恶意登陆尝试导致的资源枯竭类DOS攻击；比如限制日志记录占用的磁盘空间。
* 规则5：禁止日志文件和操作系统存储在同一个分区中，同时，应使用转储、滚动、轮循机制，来防止存储日志的分区写满。
    * 说明：所需空间和具体业务、局点容量、日志保存周期相关，要根据实际情况估算。
* 规则6：安全日志应该有备份及清理机制
    * 说明：备份及清理机制包括定期备份及清理安全日志和监控用于存放安全日志的磁盘空间的使用情况。可以配置定期备份及清理的时间，可以配置以用于存放安全日志的磁盘空间使用率达到多少时进行备份及清理。
* 规则7：通过网络形式保存安全日志
    * 说明：在生成安全日志时，即时将日志保存到网络上其他主机，而且生成安全日志的应用程序不能再访问存放在其他主机的日志。

## 2.7 Web Service
### 2.7.1 使用规则
* 规则1： 对Web Service接口的调用必须进行认证
    * 说明：认证就是确定谁在调用Web Service，并且证实调用者身份。
    * 实施指导：
        * 可以通过在消息头中增加用户名和口令，作为认证凭据；
        * 对于安全性要求不高、只向同一信任域内其他主机开放的Web Service接口，可以通过简单的IP认证来实现接口的认证（只有服务器端指定IP地址的客户端才允许调用，IP地址可配置）。
* 规则2：如果调用者的权限各不相同，那么必须对Web Service接口的调用进行鉴权。
    * 说明：鉴权就是判断调用者是否有权限调用该Web Service接口。
    * 实施指导：可以通过Axis的handler对调用进行鉴权。
* 规则3: 通过Web Service接口传递敏感数据时，必须保障其机密性
    * 实施指导：采用https安全协议。
* 规则4：通过Web Service接口传递重要的交易数据时，必须保障其完整性和不可抵赖性。
    * 说明：重要的交易数据，如转账时涉及的“转入账号”、“转出账号”、“金额”等。
* 规则5：如果Web Service只对特定的IP开放，那么必须对调用Web Service接口的客户端IP进行鉴权，只有在IP地址白名单中的客户端才允许调用，IP地址白名单可配置
* 规则6：对Web Service接口调用进行日志记录
    * 说明：日志内容包括但不限于如下内容：调用时间、操作类型、调用接口名称、详细的接口参数、客户端IP、客户端机器名、调用者的用户标识、受影响的个体（数据、资源）、成功或失败标识。
* 规则7：必须对Web Service提交的参数进行输入校验。

## 2.8 输入校验
### 2.8.1 使用规则
* 规则1：必须对所有用户产生的输入进行校验，一旦数据不合法，应该告知用户输入非法并且建议用户纠正输入
    * 说明：用户产生的输入是指来自text、password、textareas或file表单域的数据；必须假定所有用户产生的输入都是不可信的，并对它们进行合法性校验。
    * 对特殊字符进行过滤处理,如：<span style="color:skyBlue;">“;|and|exec|insert|select|delete|update|count|*|%|chr|mid|master|truncate|char|declare|","|" 、“.*[`~!@#$%^&*()+=|{}':;',\\[\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。，、？\\\\]+.*"<span>
    * 实施指导：
        * java特殊字符处理函数：
        ```
            public static boolean checkSpecialChar(String str) throws PatternSyntaxException {
                // 清除掉所有特殊字符
                String regEx = ".*[`~!@#$%^&*()+=|{}':;,\\[\\].<>/?！￥…（）—【】‘；：”“’。，、？\\\\]+.*";
                Pattern p = Pattern.compile(regEx);
                Matcher m = p.matcher(str);
                return m.matches();
            }

            public static String filterString(String str) throws PatternSyntaxException {

                String regEx = "[`~!@#$%^&*()+=|{}':;',\\[\\].<>/?！￥…（）—【】‘；：”“’。，、？\\\\]";
                Pattern p = Pattern.compile(regEx);
                Matcher m = p.matcher(str);
                return m.replaceAll("_").trim();
            }
        ```
        * javascript特殊字符处理函数：
        ```
            function checkSpecialChar(str) {  
                 var pattern = new RegExp("[`~!@#$^&*()=|{}':;',\\[\\].<>/?~！@#￥……&*（）&mdash;———|{}【】‘；：”“'。，、？\\\\]+");
                 return  pattern.test(str);
            }
            function replaceSpecialChar(s,replacementChar) {
                 var pattern = new RegExp("[`~!@#$^&*()=|{}':;',\\[\\].<>/?~！@#￥……&*（）&mdash;———|{}【】‘；：”“'。，、？\\\\]");
                 var rs = "";
                 for (var i = 0; i < s.length; i++) {
                   rs = rs + s.substr(i, 1).replace(pattern, replacementChar);
                 }
                 return rs;
            }
        ```
* 规则2：必须对所有服务器产生的输入进行校验，一旦数据不合法，必须使会话失效，并记录告警日志
    * 说明：服务器产生的输入是指除用户产生的输入以外的输入，例如来自hidden fields、selection boxes、check boxes、radio buttons、cookies、HTTP headers、热点链接包含的URL参数的数据或客户端脚本等；必须假定所有服务器产生的输入都是被篡改过的、恶意的，并对它们进行合法性校验，如果不合法，说明有人恶意篡改数据。举例：假如用户资料填写表单中的“性别”为必填项，用radio button（‘男’和‘女’对应实际值分别为‘1’和‘0’）来限制用户的输入，如果应用程序收到的“性别”值为‘2’，那么可以断定有人恶意篡改数据。
* 规则3：禁止将HTTP标题头中的任何未加密信息作为安全决策依据
    * 说明：HTTP 标题头是在 HTTP 请求和 HTTP 响应的开始阶段发送的。应用系统程序必须确保不以 HTTP 标题头中的任何未加密信息作为安全决策依据，因为攻击者要操作这一标题头是很容易的。例如，标题头中的 referer 字段包含来自请求源端的 Web 页面的 URL。不要根据 referer 字段的值做出任何安全决策（如检查请求是否来源于 应用系统程序生成的页面），因为该字段是很容易被伪造的。
* 规则4：不能依赖于客户端校验，必须使用服务端代码对输入数据进行最终校验
    * 说明：客户端的校验只能作为辅助手段，减少客户端和服务端的信息交互次数。
* 规则5：对于在客户端已经做了输入校验，在服务器端再次以相同的规则进行校验时，一旦数据不合法，必须使会话失效，并记录告警日志
    * 说明：肯定存在攻击行为，攻击者绕过了客户端的输入校验，因此必须使会话失效，并记入告警日志
* 规则6：如果输入为数字参数则必须进行数字型判断
    * 说明：这里的数字参数指的是完全由数字组成的数据。
    * 实施指导：
    ```
        String mobileno = request.getParameter("mobileno");
        String characterPattern = "^\\d+$";   //正则表达式表示是否全为数字
        if (!mobileno.matches (characterPattern)){
            out.println (“Invalid Input”);
        }
    ```
* 规则7：如果输入只允许包含某些特定的字符或字符的组合，则使用白名单进行输入校验
    * 说明：对于一些有规则可循的输入，如email地址、日期、小数等，使用正则表达式进行白名单校验，这样比使用黑名单进行校验更有效。
    * 实施指导：
    ```
    email地址校验的方法：
    String emailAddress = request.getParameter("emailAddress");
    // email正则表达式
    String characterPattern = "^([a-z0-9A-Z]+[_-]?)+[a-z0-9A-Z]@(([a-z0-9A-Z]+[_-]?)+(-[a-z0-9A-Z]+)?\\.)+[a-zA-Z]{2,4}$";
    if (!emailAddress.matches(characterPattern)){
        out.println (“Invalid Email Address”);
    }
    ```
* 规则8：如果输入为字符串参数则必须进行字符型合法性判断
    * 说明：可定义一个合法字符集。
规则9：校验输入数据的长度
    * 说明：如果输入数据是字符串，必须校验字符串的长度是否符合要求，长度校验会加大攻击者实施攻击的难度。
* 规则10：校验输入数据的范围
    * 说明：如果输入数据是数值，必须校验数值的范围是否正确，如年龄应该为0～150之间的正整数
* 规则11：禁止通过字符串串联直接使用用户输入构造可执行 SQL 语句
    * 说明：禁止通过字符串串联直接使用用户输入构造可执行 SQL 语句，<span style="color:skyBlue;">如：string sql = "select status from Users where UserName='" + txtUserName.Text + "'";</span>这样很容易被SQL注入攻击
* 规则12：对于java/JSP语言，使用预编译语句PreparedStatement代替直接的语句执行Statement
    * 说明：使用预编译语句PreparedStatement，类型化 SQL 参数将检查输入的类型，确保输入值在数据库中当作字符串、数字、日期或boolean等值而不是可执行代码进行处理，从而防止SQL注入攻击。而且，由于 PreparedStatement 对象已预编译过，所以其执行速度要快于 Statement 对象。因此，多次执行的 SQL 语句经常创建为 PreparedStatement 对象，还可以提高效率。
* 规则13：禁止动态构建XPath语句
    * 说明：和动态构建SQL一样，动态构建XPath语句也会导致注入漏洞（XPath注入）。动态构建XPath语句的例子：public boolean doLogin(String loginID, String password){......
	XPathExpression expr = xpath.compile("//users/user[loginID/text()='"+loginID+"' and password/text()='"+password+"' ]/firstname/text()");
* 规则14：在JavaBean中禁止使用property="*"进行参数赋值
    * 说明：property="*"这表明用户在可见的JSP页面中输入的，或是直接通过Query String提交的参数值，将存储到与参数名相匹配的bean属性中。例如，网上交易程序，一般，用户是这样提交请求的：http://xx.xx.xx /addToBasket.jsp?newItem=ITEM0105342，如果用户提交：http://xx.xx.xx/addToBasket.jsp?newItem=ITEM0105342&balance=0，这样，balance=0的信息就被在存储到了JavaBean中了，而balance是整个会话中用来存储总费用的，当他们这时点击“chekout”结账的时候，费用就全免了
* 规则15：用于重定向的输入参数不能包含回车和换行字符，以防止HTTP响应拆分攻击
    * 说明：注意，“回车”字符有多种表示方式（CR = %0d = \r ），“换行”字符有多种表示方式（LF = %0a = \n）。
* 规则16：如果服务端代码执行操作系统命令，禁止从客户端获取命令
    * 说明：如果服务端代码中使用Runtime.getRuntime().exec(cmd)或ProcessBuilder等执行操作系统命令，那么禁止从客户端获取命令；而且最好不要从客户端获取命令的参数，如果必须从客户获取命令的参数，那么必须采用正则表达式对命令参数进行严格的校验，以防止命令注入（因为，一旦从客户端获取命令或参数，通过;&|<>符号，非常容易构造命令注入，危害系统）

## 2.9 输出编码
### 2.9.1 使用规则
* 规则1： 对于不可信的数据，输出到客户端前必须先进行HTML编码
    * 说明：不可信的数据（也就是其他业务系统生成的未经本应用系统验证的表数据或文件数据），通过对输出到客户端的数据进行编码，可以防止浏览器将 HTML 视为可执行脚本，从而防止跨站脚本攻击。
    * 实施指导：
    ```
    JSP语言可以通过替换输出数据的特殊字符【& < > ” ’ ( )%+-】为其他表示形式后再输出给客户端
    <%
        String OutStr = "<script>alert('XSS')</script>";
        OutStr = OutStr.replaceAll("&","&amp;");
        OutStr = OutStr.replaceAll("<","&lt;");
        OutStr = OutStr.replaceAll(">","&gt;");
        OutStr = OutStr.replaceAll("\"","&quot;");
        OutStr = OutStr.replaceAll("\'","&#39;");
        OutStr = OutStr.replaceAll("\\(","&#40;");
        OutStr = OutStr.replaceAll("\\)","&#41;");
        out.println(OutStr);
    %>
    ASP.NET语言可以通过HtmlEncode方法对 HTML 的输出进行编码。
    PHP语言可以通过htmlentities或htmlspecialchars方法对HTML输出进行编码。
    ```
## 2.10 防重放攻击
### 2.10.1 使用规则
* 规则1：对数据包进行重放攻击防御处理
    * 说明：所谓重放攻击就是攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程。攻击者利用网络监听或者其他方式盗取认证凭据，之后再把它重新发给认证服务器。从这个解释上理解，加密可以有效防止会话劫持，但是却防止不了重放攻击。重放攻击任何网络通讯过程中都可能发生。
    * 实施指导：
    ```
    （1）时间戳: “时戳”──代表当前时刻的数
    　　基本思想──A接收一个消息当且仅当其包含一个对A而言足够接近当前时刻的时戳
    　　原理──重放的时戳将相对远离当前时刻
    　　时钟要求──通信各方的计算机时钟保持同步
    　　处理方式──设置大小适当的时间窗（间隔），越大越能包容网络传输延时，越小越能防重放攻击
    　　适用性──用于非连接性的对话 （在连接情形下双方时钟若偶然出现不同步，则正确的信息可能会被误判为重放信息而丢弃，而错误的重放信息可能会当作最新信息而接收）
    （2）序号
    　　通信双方通过消息中的序列号来判断消息的新鲜性
    　　要求通信双方必须事先协商一个初始序列号，并协商递增方法
    （3）提问——应答
    　　“现时”──与当前事件有关的一次性随机数N（互不重复即可）
    　　基本做法──期望从B获得消息的A 事先发给B一个现时N，并要求B应答的消息中包含N或f(N)，f是A、B预先约定的简单函数
    　　原理──A通过B回复的N或f(N)与自己发出是否一致来判定本次消息是不是重放的
    　　时钟要求──无
    　　适用性──用于连接性的对话
    ```
## 2.11 上传下载
### 2.11.1 使用规则
* 规则1：必须在服务器端采用白名单方式对上传或下载的文件类型、大小进行严格的限制
* 规则2：禁止以用户提交的数据作为读/写/上传/下载文件的路径或文件名，以防止目录跨越和不安全直接对象引用攻击
    * 禁止以用户提交的数据作为读/写/上传/下载文件的路径或文件名，以防止目录跨越和不安全直接对象引用攻击
* 规则3：禁止将敏感文件（如日志文件、配置文件、数据库文件等）存放在Web内容目录下
    * 说明：Web内容目录指的是：通过Web可以直接浏览、访问的目录，存放在Web内容目录下的文件容易被攻击者直接下载。

## 2.12 异常处理
### 2.12.1 使用规则
* 规则1：应用程序出现异常时，禁止向客户端暴露不必要的信息，只能向客户端返回一般性的错误提示消息
    * 说明：应用程序出现异常时，禁止将数据库版本、数据库结构、操作系统版本、堆栈跟踪、文件名和路径信息、SQL 查询字符串等对攻击者有用的信息返回给客户端。建议重定向到一个统一、默认的错误提示页面，进行信息过滤。
* 规则2：应用系统捕获异常，并在日志中记录详细的错误信息
    * 说明：记录详细的错误消息，可供入侵检测及问题定位。

## 2.13 代码注释
### 2.13.1 使用规则
* 规则1：在注释信息中禁止包含物理路径信息
* 规则2：在注释信息中禁止包含数据库连接信息
* 规则3：在注释信息中禁止包含SQL语句信息
* 规则4：对于静态页面，在注释信息中禁止包含源代码信息
* 规则5：对于动态页面不使用普通注释，只使用隐藏注释
    * 说明：动态页面包括ASP、PHP、JSP、CGI等由动态语言生成的页面。通过浏览器查看源码的功能，能够查看动态页面中的普通注释信息，但看不到隐藏注释（隐藏注释不会发送给客户端）。因此，为了减少信息泄漏，建议只使用隐藏注释。
    * 实施指导：<%-- 隐藏注释1 --%>

## 2.14 归档要求
### 2.14.1 使用规则
* 规则1：版本归档时，必须删除开发过程（包括现场定制）中的临时文件、备份文件、无用目录等。
    * 说明：恶意用户可以通过URL请求诸如.bak之类的文件，应用系统服务器会将这些文件以文本方式呈现给恶意用户，造成代码的泄漏，严重威胁应用系统的安全。
    * 实施指导：
    ```
    在应用系统的根目录下执行以下命令：
        find ./ -name "*.old" -o -name "*.OLD" -o -name "*.bak" -o -name "*.BAK" -o -name "*.temp" -o -name "*.tmp" -o -name "*.save" -o -name "*.backup" -o -name "*.orig" -o -name "*.000" -o -name "*~" -o -name "*~1" -o -name "*.dwt" -o -name "*.tpl" -o -name "*.zip" -o -name "*.7z" -o -name "*.rar" -o -name "*.gz" -o -name "*.tgz" -o -name "*.tar" -o -name "*.bz2"
        分析查找到的文件是否临时文件、备份文件、无用文件，如果是则删除
    ```
* 规则2：归档的页面程序文件的扩展名必须使用小写字母
    * 说明：很多Web server对大小写是敏感的，但对后缀的大小写映像并没有做正确的处理。攻击者只要在URL中将JSP文件后缀从小写变成大写，应用系统服务器就不能正确处理这个文件后缀，而将其当作纯文本显示。攻击者可以通过查看源码获得这些程序的源代码。因此，归档的页面程序文件的扩展名必须使用小写字母，如jsp、html、htm、asp等页面程序文件的扩展名分别为jsp、html、htm、asp。
* 规则3：归档的程序文件中禁止保留调试用的代码。
    * 说明：这里的“调试用的代码”是指开发过程中进行临时调试所用的、在Web应用运行过程中不需要使用到的Web页面代码或servlet代码。例如：在代码开发过程中为了测试一个添加帐号的功能，开发人员临时编写了一个JSP页面进行测试，那么在归档时，该JSP页面必须删除，以免被攻击者利用。
## 2.15 文档管控
### 2.15.1 使用规则
* 规则1：对开发过程中文档实现绑定责任人，实行谁打印谁负责机制
    * 说明：对终端打印进行权限管理，将打印机和PC两者绑定。并且对打印文件强制附加 “计算机名”、“账号”、“IP”、“打印时间”、“文件名”、“页数”等水印信息。对打印内容以图片形式自动进行备份。这样不但可申明责任人，还可提升责任人保护文件安全意识。当文件丢失时，还能快速跟踪文件去向，追究责任。如需打印多份文件，还可规定打印人对打印文件关键处做手动标记，并承担监管责任。
* 规则2：设定流转周期，回收重要文件
    * 说明：如果打印出来的文件在使用后未能及时回收或销毁，一旦被人利用，便可能引起信息泄密。为进一步确保重要打印文件安全，还可在打印前对打印资料设定流转周期，如：开发用图纸，可指定开发周期，在周期结束后，让负责人立即回收处理，防止文件因搁置忽略而遭泄露。

## 2.16 变量、结构
* 规则1：去掉没必要的公共变量。
    * 说明：公共变量是增大模块间耦合的原因之一，故应减少没必要的公共变量以降低模块间的耦合度。
* 规则2：仔细定义并明确公共变量的含义、作用、取值范围及公共变量间的关系。
    * 说明：在对变量声明的同时，应对其含义、作用及取值范围进行注释说明，同时若有必要还应说明与其它变量的关系。
* 规则3：确公共变量与操作此公共变量的函数或过程的关系，如访问、修改及创建等。
    * 说明：明确过程操作变量的关系后，将有利于程序的进一步优化、单元测试、系统联调以及代码维护等。这种关系的说明可在注释或文档中描述。
* 规则4：当向公共变量传递数据时，要十分小心，防止赋与不合理的值或越界等现象发生。
    * 说明：对公共变量赋值时，若有必要应进行合法性检查，以提高代码的可靠性、稳定性。
* 规则5：防止局部变量与公共变量同名。
    * 说明：若使用了较好的命名规则，那么此问题可自动消除。
* 规则6：严禁使用未经初始化的变量作为右值。
    * 说明：特别是在C/C++中引用未经赋值的指针，经常会引起系统崩溃。

## 2.17 程序效率
* 规则1：编程时要经常注意代码的效率。
    * 说明：代码效率分为全局效率、局部效率、时间效率及空间效率。
        * 全局效率是站在整个系统的角度上的系统效率；
        * 局部效率是站在模块或函数角度上的效率；
        * 时间效率是程序处理输入任务所需的时间长短；
        * 空间效率是程序所需内存空间，如机器代码空间大小、数据空间大小、栈空间大小等
* 规则2：在保证软件系统的正确性、稳定性、可读性及可测性的前提下，提高代码效率。
    * 说明：不能一味地追求代码效率，而对软件的正确性、稳定性、可读性及可测性造成影响。
* 规则3：局部效率应为全局效率服务，不能因为提高局部效率而对全局效率造成影响。
* 规则4：通过对系统数据结构的划分与组织的改进，以及对程序算法的优化来提高空间效率。
    * 说明：这种方式是解决软件空间效率的根本办法。
* 规则5：循环体内工作量最小化。
    * 说明：应仔细考虑循环体内的语句是否可以放在循环体之外，使循环体内工作量最小，从而提高程序的时间效率。

## 2.18 代码编辑、编译、审查
* 规则1：打开编译器的所有告警开关对程序进行编译。
* 规则2：在产品软件（项目组）中，要统一编译开关选项。
* 规则3：通过代码走读及审查方式对代码进行检查。
    * 说明：
        * 代码走读主要是对程序的编程风格如注释、命名等以及编程时易出错的内容进行检查，可由开发人员自己或开发人员交叉的方式进行；
        * 代码审查主要是对程序实现的功能及程序的稳定性、安全性、可靠性等进行检查及评审，可通过自审、交叉审核或指定部门抽查等方式进行。
* 规则4：测试部测试产品之前，应对代码进行抽查及评审。

## 2.19 代码测试、维护
* 规则1：单元测试要求至少达到语句覆盖。
* 规则2：单元测试开始要跟踪每一条语句，并观察数据流及变量的变化。
* 规则3：清理、整理或优化后的代码要经过审查及测试。
* 规则4：代码版本升级要经过严格测试。
* 规则5：使用工具软件对代码版本进行维护。
* 规则6：正式版本上软件的任何修改都应有详细的文档记录。
## 2.16 其它
* 规则1：对于JSP语言，所有servlet必须进行静态映射，不允许通过绝对路径访问
    * 说明：在web.xml文件中为servlet配置URI映射，使用servlet时，引用它的URI映射，而不允许通过绝对路径访问。
* 规则2：对客户端提交的表单请求进行合法性校验，防止跨站请求伪造攻击
    * 说明：跨站请求伪造（CSRF）是一种挟制终端用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。攻击者可以迫使用户去执行攻击者预先设置的操作，例如，如果用户登录网络银行去查看其存款余额，他没有退出网络银行系统就去了自己喜欢的论坛去灌水，如果攻击者在论坛中精心构造了一个恶意的链接并诱使该用户点击了该链接，那么该用户在网络银行帐户中的资金就有可能被转移到攻击者指定的帐户中。当CSRF针对普通用户发动攻击时，将对终端用户的数据和操作指令构成严重的威胁；当受攻击的终端用户具有管理员帐户的时候，CSRF攻击将危及整个Web应用程序。
    * 实施指导：
    ```
    方法一：为每个session创建唯一的随机字符串，并在受理请求时验证
    <form  action="/transfer.do" method="post">
        <input type="hidden" name="randomStr" value=<%=request.getSession().getAttribute("randomStr")%>>
        ......
    </form>
    //判断客户端提交的随机字符串是否正确
    String randomStr = (String)request.getParameter("randomStr");
    if(randomStr == null) randomStr="";
    if(randomStr.equals(request.getSession().getAttribute("randomStr")))
    {//处理请求}
    else{
    //跨站请求攻击，注销会话
    }
    方法二：受理重要操作请求时，在相应的表单页面增加图片验证码，用户提交操作请求的同时提交验证码，在服务器端先判断用户提交的验证码是否正确，验证码正确再受理操作请求。
    ```
* 规则3：禁止使用eval()函数来处理用户提交的字符串
    * 说明：eval()函数存在安全隐患，该函数可以把输入的字符串当作JavaScript表达式执行，容易被恶意用户利用。
* 规则4：关闭登录窗体表单中的自动填充功能，以防止浏览器记录用户名和口令。
    * 说明：浏览器都具有自动保存用户输入数据和自动填充数据的能力。为了保障用户名和口令的安全，必须关闭自动填充选项，指示浏览器不要存储登录窗口中用户名、口令等敏感信息。
* 规则5：：防止网页被框架盗链或者点击劫持
    * 说明：框架盗链和点击劫持（ClickJacking）都利用到框架技术，防范措施就是防止网页被框架。
    * 实施指导：
    ```
        在每个网页上增加如下脚本来禁止iframe嵌套：
        < <script>
            if(top != self) top.location.href = location.href;
        </script>
    ```
