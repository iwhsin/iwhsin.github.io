## 概要简介
> 在每个类中，在重写`equals`方法的时侯，一定要重写`hashcode`方法。如果不这样做，你的类违反了`hashCode`的通用约定，这会阻止它在`HashMap`和`HashSet`这样的集合中正常工作。

## 规范约束
### 通用约定
1. 在一个对象上重复调用`hashCode`方法时，它必须始终返回相同的值。
```
当在一个应用程序执行过程中，如果在`equals`方法比较中没有修改任何信息，在一个对象上重复调用`hashCode`方法时，它必须始终返回相同的值。从一个应用程序到另一个应用程序的每一次执行返回的值可以是不一致的。 
```
2. 如果两个对象根据`equals(Object)`方法比较是相等的，那么在两个对象上调用`hashCode`就必须产生的结果是相同的整数。
3. 两个通过`equals`方法比较不相等的对象，调用`hashCode`方法返回的值可以是相同的，但是建议返回不同的值。
```
如果两个对象根据`equals(Object)`方法比较并不相等，则不要求在每个对象上调用`hashCode`都必须产生不同的结果。 但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表（hash tables）的性能。 
```
### 编写高质量的`hashCode`方法
> 一个好的`hash`方法趋向于为不相等的实例生成不相等的哈希码。这也正是`hashCode`约定中第三条的表达。理想情况下，`hash`方法为集合中不相等的实例均匀地分配`int`范围内的哈希码。实现这种理想情况可能是困难的。 幸运的是，要获得一个合理的近似的方式并不难。 
* HashCode值的计算
    1. 声明一个`int`类型的result，并初始化为第一个关键元素的`hashCode`值。
    2. 对于剩下的关键元素x进行如下操作计算其hashCode值并累加`result = 31*result + hashCode(x);`
         * 基本数据类型hashCode计算：
            * boolean：return x ? 1:0;
            * byte、char、short、int：return x;
            * long：return (int)(x ^ (x >>> 32));
            * double：long tmp = Double.doubleToLongBits(x);return (int) (temp ^ (temp >>> 32));
            * float：return x != +0.0f ? Float.floatToIntBits(x) : 0;
        * 引用数据类型直接使用递归计算：x.hashCode();
    3. 返回计算后的result值。
### 注意事项
1. 不要试图从哈希码计算中排除重要的属性来提高性能。
```
由此产生的哈希函数可能运行得更快，但其质量较差可能会降低哈希表的性能，使其无法使用。
```
2. 不要为`hashCode`返回的值提供详细的规范，因此客户端不能合理地依赖它； 你可以改变它的灵活性。
```
Java 类库中的许多类（例如 String 和 Integer）都将 hashCode 方法返回的确切值指定为实例值的函数。 这不是一个好主意，而是一个我们不得不忍受的错误：它妨碍了在未来版本中改进哈希函数的能力。 如果未指定细节并在散列函数中发现缺陷，或者发现了更好的哈希函数，则可以在后续版本中对其进行更改。
```