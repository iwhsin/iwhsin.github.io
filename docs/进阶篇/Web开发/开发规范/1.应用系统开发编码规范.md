# 1 应用系统开发编码规范
## 1.1 JAVA代码开发规范
### 1.1.1 命名规范
* 总体原则:
    * 见名知意，简洁统一；
    * 除了包名，静态常量等特殊情况，统一使用驼峰命名规则；

### 1.1.2 常量定义
1. 【强制】在long或者Long赋值时，数值后使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解。
2. 【推荐】不允许在代码中直接使用未经预先定义的常量，所有使用的常量均需要预先进行定义。
3. 【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护；
4. 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量
    * 跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下；
    * 应用内共享常量：放置在一方库中，通常是子模块中的constant目录下；
    * 子工程内部共享常量：即在当前子工程的constant目录下；
    * 包内共享常量：即在当前包下单独的constant目录下；
    * 类内共享常量：直接在类内部`private static final`定义。
5. 【推荐】按照正确的顺序声明字段的修饰符。
    * 修饰字段顺序： `Annotations→public→protected→private→abstract→static→final→transient→volatile→synchronized→native→strictfp`

### 1.1.3 格式规范
1. 【强制】第一个非注释行应该为包语句。
2. 【强制】删除不用的导入，尽量不要使用通配符“*”进行整个包的导入，防止命名冲突或影响编译速度。
    * 说明: 按需类型引入(包引入)不会降低Java代码的运行速度但影响Java代码的编译速度。

### 1.1.4 语句规范
#### 1.1.4.1 异常控制语句-Exception Control Statement
1. 【强制】Java类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。
2. 【强制】异常不要用来做流程控制，使用条件进行控制。
3. 【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。
4. 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。
5. 【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。如果JDK7及以上，请使用try-with-resources方式。
6. 【强制】不要在finally块中使用return。
7. 【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。
8. 【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。
9. 【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景
    * 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。反例：public int f() { return Integer对象}，如果为null，自动解箱抛NPE。
    * 数据库的查询结果可能为null。
    * 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。
    * 远程调用返回对象时，一律要求进行空指针判断，防止NPE。
    * 对于Session中获取的数据，建议NPE检查，避免空指针。
    * 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。
10. 【推荐】定义时区分unchecked/checked异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException/ServiceException等。
> 备注：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，不得不通过catch NumberFormatException来实现。

#### 1.1.4.2 构造/析构-Constructor/Finalizer
1. 【推荐】要初始化父类的构造函数。
2. 【推荐】不要在构造函数中初始化静态数据，应在声明中初始化。
3. 【推荐】用构造函数做简单初始化, 复杂的功能应留到其他的方法在构造函数后执行。
4. 【推荐】使用Finalize()释放资源，不过不要完全依赖Finalize，资源要尽可能早的进行释放。
    ```
    finalize() {
        if (NotReleased()) {
            try {
                releaseResource();
            }catch (Throwable t) {
                handleError();
            }
        }
    }
    ```

#### 1.1.4.3 方法-Method
1. 【推荐】尽可能缩小方法的能够被访问的范围。如果不需要类以外的方法访问的方法则使用private，而只需要package范围内访问的方法使用default，若即要package内的代码能够访问又要求其继承类能够访问则使用protected，最后若需要所有的代码都可以访问则再使用public。
2. 【推荐】应尽可能验证所有传入参数，不能假定非空对象, 验证有错误时返回明确的错误信息。
3. 【推荐】尽量保证每个方法只有一个出口，否则可能出现丢失返回的情况。
    ```
    boolean check() {
        boolean result = false;
        if (...) {
            result = true;
        }
        return result;
    }
    ```

#### 1.1.4.4 资源-Resource
1. 【强制】诸如Statement/Steam这类资源，Java7以上使用try-with-resource的方式，Java7以下使用try{}finally{}模式关闭。

#### 1.1.4.4 SQL使用
1. 【强制】禁止使用拼装SQL，须使用参数绑定。

### 1.1.5 日志规范
1. 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。
    ```
    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    private static final Logger LOGGER = LoggerFactory.getLogger(Abc.class);
    ```
2. 【强制】在正式提交的代码中，不允许使用System.out方式打印信息。
3. 【强制】日志输出应当接入统一日志管理平台。
4. 【强制】日志中的敏感信息输出需要满足指定脱敏规则进行脱敏处理。
5. 【强制】日志应区分如下几类情形：
    * 发生致命错误时运行将终止（fatal）；
    * 发生错误，仍可继续执行(error)；
    * 发生警告仍可继续执行(warn)；
    * 记录运行过程或干预情况(info)；
    * 调试程序记录信息等(debug)；
6. 【强制】对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方式，不使用“+”拼接形式。
    * 对于debug日志输出应该先判断日志输出级别
    ```
    if (logger.isDebugEnabled()) {
        logger.debug("Processing trade with id: {} and symbol: {} ", id, symbol);
    }
    ```
7. 【推荐】禁止打印重复信息，不要抛出异常后又输出日志，如捕获异常后又抛出了自定义业务异常（ServiceException），此时无需记录错误日志，由最终捕获方进行异常处理。
8. 【推荐】不要在单条日志中打印过多如荣，如整个列表数据、map数据或报文数据，这样可能会拖垮你的应用程序，如果你的程序响应时间变慢，那要考虑日志是否打印过多。
9. 【强制】禁止在线上环境开启debug。

## 1.2 SQL开发规范
### 1.2.1 SQL编写规范
1. 【强制】应避免写非常复杂的SQL语句;
2. 【强制】SQL语句不应在客户端组织，而应在服务器端组织；
3. 【强制】SQL语句的语法应与所使用的数据库相适应；
4. 【强制】应确保变量和参数的类型和大小与数据库中表数据列相匹配；
5. 【强制】使用SELECT语句时，应指出列名，不应使用列的序号或者用“*”替代所有列名；
6. 【强制】使用INSERT语句时，应指定插入的字段名，不应不指定字段名直接插入VALUES；
7. 【强制】如果SQL语句连接多表时，应使用表的别名来引用列
8. 【强制】SQL语句应避免对大表的全表扫描操作，对大表的操作应尽量使用索引；
9. 【强制】SQL语句应避免不必要的排序；
10. 【强制】SQL语句应避免删除全表的操作；
11. 【强制】在含有子查询的SQL语句中，应减少对表的查询；
12. 【强制】SQL语句尽可能避免多表联合复杂查询；
13. 【强制】应将SQL语句中的数据库函数、计算表达式等放置在等号右边；
14. 【强制】在事务完整性的基础上，SQL语句应在程序中显式使用 COMMIT，ROLLBACK，尽快提交事务，释放系统资源；
15. 【强制】SQL语句应避免频繁引起数据库事务回滚；
16. 【强制】SQL语句中出现的所有表名、表别名、字段名、序列等数据库对象都应小写；
17. 【推荐】应使用变量绑定实现SQL语句共享，避免使用硬编码；
18. 【推荐】应按照业务需要使用事务，同时应保持事务简短，避免大事务。
19. 【推荐】SQL 语句中出现的系统保留字、内置函数名、SQL保留字、绑定变量等都应大写；

### 1.2.2 索引使用规范
01. 【强制】查询列、排序列应与索引列次序保持一致。
02. 【强制】应避免在WHERE子句中使用计算后的索引列。
03. 【强制】应避免在WHERE子句索引列上使用函数或者表达式。如果确需使用，应建立对应的函数索引。
04. 【强制】应避免在WHERE子句中对索引列使用IS NULL，IS NOT NULL。
05. 【强制】索引列的比较应避免使用<>，NOT。
06. 【强制】应避免在WHERE子句中对索引列使用LIKE ’%xxx%’,’%xxx’。可在WHERE子句中对索引列使用LIKE ’xxx%’，此种方式仍会使用索引。
07. 【强制】应避免对索引列值进行隐式/显式转换。
08. 【强制】应尽量使用与索引列数据类型保持一致的比较值。
09. 【强制】在 WHERE子句中应注意比较值与索引列数据类型的一致性，应显式转换比较值使其与索引列数据类型保持一致。
10. 【强制】应避免比较同一张表中的列。
11. 【强制】对于复合索引，WHERE子句中必须包含索引的第一列才一定能够使用到索引。
12. 【强制】为保证SQL的执行效率，应避免使用UNION、OR 子句，可考虑在应用中对结果集进行处理。
13. 【推荐】索引的建立应慎重考虑，不是越多越好。索引可以提高相应的select的效率，但同时也降低了INSERT及UPDATE的效率。
14. 【推荐】被查询列有大量重复数据时，如状态标志，可考虑建立位图索引。位图索引只对基于COST优化时有效。
15. 【推荐】IN、OR子句常会使用工作表，导致索引无效。如果不产生大量重复值，可以考虑把子句拆开；拆开的子句中应包含索引。
